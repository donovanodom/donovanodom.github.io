[
  {
    "id": 1,
    "title": "Count Unguarded Cells in the Grid",
    "content": "\u003Cp\u003EYou are given two integers \u003Ccode\u003Em\u003C/code\u003E and \u003Ccode\u003En\u003C/code\u003E representing a \u003Cstrong\u003E0-indexed\u003C/strong\u003E \u003Ccode\u003Em x n\u003C/code\u003E grid. You are also given two 2D integer arrays \u003Ccode\u003Eguards\u003C/code\u003E and \u003Ccode\u003Ewalls\u003C/code\u003E where \u003Ccode\u003Eguards[i] = [row\u003Csub\u003Ei\u003C/sub\u003E, col\u003Csub\u003Ei\u003C/sub\u003E]\u003C/code\u003E and \u003Ccode\u003Ewalls[j] = [row\u003Csub\u003Ej\u003C/sub\u003E, col\u003Csub\u003Ej\u003C/sub\u003E]\u003C/code\u003E represent the positions of the \u003Ccode\u003Ei\u003Csup\u003Eth\u003C/sup\u003E\u003C/code\u003E guard and \u003Ccode\u003Ej\u003Csup\u003Eth\u003C/sup\u003E\u003C/code\u003E wall respectively.\u003C/p\u003E\n\n\u003Cp\u003EA guard can see \u003Cb\u003Eevery\u003C/b\u003E cell in the four cardinal directions (north, east, south, or west) starting from their position unless \u003Cstrong\u003Eobstructed\u003C/strong\u003E by a wall or another guard. A cell is \u003Cstrong\u003Eguarded\u003C/strong\u003E if there is \u003Cstrong\u003Eat least\u003C/strong\u003E one guard that can see it.\u003C/p\u003E\n\n\u003Cp\u003EReturn\u003Cem\u003E the number of unoccupied cells that are \u003Cstrong\u003Enot\u003C/strong\u003E \u003Cstrong\u003Eguarded\u003C/strong\u003E.\u003C/em\u003E\u003C/p\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 1:\u003C/strong\u003E\u003C/p\u003E\n\u003Cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/10/example1drawio2.png\" style=\"width: 300px; height: 204px;\" /\u003E\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E m = 4, n = 6, guards = [[0,0],[1,1],[2,3]], walls = [[0,1],[2,2],[1,4]]\n\u003Cstrong\u003EOutput:\u003C/strong\u003E 7\n\u003Cstrong\u003EExplanation:\u003C/strong\u003E The guarded and unguarded cells are shown in red and green respectively in the above diagram.\nThere are a total of 7 unguarded cells, so we return 7.\n\u003C/pre\u003E\n\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 2:\u003C/strong\u003E\u003C/p\u003E\n\u003Cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/10/example2drawio.png\" style=\"width: 200px; height: 201px;\" /\u003E\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E m = 3, n = 3, guards = [[1,1]], walls = [[0,1],[1,0],[2,1],[1,2]]\n\u003Cstrong\u003EOutput:\u003C/strong\u003E 4\n\u003Cstrong\u003EExplanation:\u003C/strong\u003E The unguarded cells are shown in green in the above diagram.\nThere are a total of 4 unguarded cells, so we return 4.\n\u003C/pre\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EConstraints:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cul\u003E\n\t\u003Cli\u003E\u003Ccode\u003E1 &lt;= m, n &lt;= 10\u003Csup\u003E5\u003C/sup\u003E\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E2 &lt;= m * n &lt;= 10\u003Csup\u003E5\u003C/sup\u003E\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E1 &lt;= guards.length, walls.length &lt;= 5 * 10\u003Csup\u003E4\u003C/sup\u003E\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E2 &lt;= guards.length + walls.length &lt;= m * n\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003Eguards[i].length == walls[j].length == 2\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E0 &lt;= row\u003Csub\u003Ei\u003C/sub\u003E, row\u003Csub\u003Ej\u003C/sub\u003E &lt; m\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E0 &lt;= col\u003Csub\u003Ei\u003C/sub\u003E, col\u003Csub\u003Ej\u003C/sub\u003E &lt; n\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003EAll the positions in \u003Ccode\u003Eguards\u003C/code\u003E and \u003Ccode\u003Ewalls\u003C/code\u003E are \u003Cstrong\u003Eunique\u003C/strong\u003E.\u003C/li\u003E\n\u003C/ul\u003E\n",
    "code": "const countUnguarded \\u003D function(m, n, guards, walls) {\\u000A  \\u000A  // create matrix based based on m and n values\\u000A  const mat \\u003D Array(m).fill().map(() \\u003D\\u003E Array(n).fill(0))\\u000A  \\u000A  // store row and column lengths and initialize total number of cells\\u000A  const row \\u003D mat.length, col \\u003D mat[0].length\\u000A  let total \\u003D row * col\\u000A  \\u000A  // iterate through walls array and set wall locations in matrix\\u000A  // each time we encounter a wall, decrement the total\\u000A  for(const [x,y] of walls){\\u000A    mat[x][y] \\u003D \\u0027W\\u0027\\u000A    total\\u002D\\u002D\\u000A  }\\u000A  \\u000A  // create a traversal function to follow the paths each guard sees\\u000A  const traverse \\u003D (initx, inity) \\u003D\\u003E {\\u000A    \\u000A    // initialize a queue with the coordinates of a guard and an object\\u000A    // with keys for each direction of traversal and corresponding values\\u000A    const q \\u003D [[initx,inity,\\u0027\\u0027]], dirs \\u003D {\\u0027u\\u0027:[\\u002D1,0],\\u0027d\\u0027:[1,0],\\u0027l\\u0027:[0,\\u002D1],\\u0027r\\u0027:[0,1]}\\u000A    \\u000A    // iterate through queue to follow the paths each guard sees\\u000A    while(q.length){\\u000A      const [x,y,dir] \\u003D q.shift()\\u000A      \\u000A      // if direction not provided this is our starting point\\u000A      // we need to check all four directions for valid paths\\u000A      if(!dir){\\u000A        Object.keys(dirs).map((key) \\u003D\\u003E {\\u000A          \\u000A          // create values for a possible next coordinates in our matrix\\u000A          // check the values to see if they are in bounds and not a wall or guard\\u000A          const [dirX, dirY] \\u003D dirs[key], nextX \\u003D x + dirX, nextY \\u003D y + dirY\\u000A          if(nextX \\u003E\\u003D 0 \\u0026\\u0026 nextY \\u003E\\u003D 0 \\u0026\\u0026 nextX \\u003C row \\u0026\\u0026 nextY \\u003C col \\u0026\\u0026 mat[nextX][nextY] !\\u003D \\u0027W\\u0027 \\u0026\\u0026 mat[nextX][nextY] !\\u003D \\u0027G\\u0027){\\u000A            \\u000A            // decrement total if next is a valid coordinate and has not already been marked as seen\\u000A            // set matrix value to 1 for seen and push next coordinates and direction to queue\\u000A            if(mat[nextX][nextY] \\u003D\\u003D 0) total\\u002D\\u002D\\u000A            mat[nextX][nextY] \\u003D 1\\u000A            q.push([nextX,nextY,key])\\u000A          }\\u000A        })\\u000A      }else{\\u000A        \\u000A        // create values for a possible next coordinate in our matrix\\u000A        // check the values to see if they are in bounds and not a wall or guard\\u000A        const [dirX, dirY] \\u003D dirs[dir], nextX \\u003D x + dirX, nextY \\u003D y + dirY\\u000A        if(nextX \\u003E\\u003D 0 \\u0026\\u0026 nextY \\u003E\\u003D 0 \\u0026\\u0026 nextX \\u003C row \\u0026\\u0026 nextY \\u003C col \\u0026\\u0026 mat[nextX][nextY] !\\u003D \\u0027W\\u0027 \\u0026\\u0026 mat[nextX][nextY] !\\u003D \\u0027G\\u0027){\\u000A          \\u000A          // decrement total if next is a valid coordinate and has not already been marked as seen\\u000A          // set matrix value to 1 for seen and push next coordinates and direction to queue\\u000A          if(mat[nextX][nextY] \\u003D\\u003D 0) total\\u002D\\u002D\\u000A          mat[nextX][nextY] \\u003D 1\\u000A          q.push([nextX,nextY,dir])\\u000A        }\\u000A      }\\u000A    }\\u000A  }\\u000A  \\u000A  // iterate through guards array and set guard locations in matrix\\u000A  // each time we encounter a guard, decrement the total\\u000A  for(const [x,y] of guards){\\u000A    mat[x][y] \\u003D \\u0027G\\u0027\\u000A    total\\u002D\\u002D\\u000A  }\\u000A  \\u000A  // iterate through guards array and run traversal function for each coordinate\\u000A  for(const [x,y] of guards){\\u000A    traverse(x, y, mat, row, col, total)\\u000A  }\\u000A  \\u000A  // return the remaining total of spaces unseen and not a wall or guard\\u000A  return total\\u000A}\\u000A\\u000A\n",
    "tags": [
      "Array",
      "Matrix",
      "Simulation"
    ],
    "created_at": "2024-10-11T18:21:15.752Z",
    "updated_at": "2024-10-11T18:21:15.752Z"
  },
  {
    "id": 2,
    "title": "Minimum Time to Visit a Cell In a Grid",
    "content": "\u003Cp\u003EYou are given a \u003Ccode\u003Em x n\u003C/code\u003E matrix \u003Ccode\u003Egrid\u003C/code\u003E consisting of \u003Cb\u003Enon-negative\u003C/b\u003E integers where \u003Ccode\u003Egrid[row][col]\u003C/code\u003E represents the \u003Cstrong\u003Eminimum\u003C/strong\u003E time required to be able to visit the cell \u003Ccode\u003E(row, col)\u003C/code\u003E, which means you can visit the cell \u003Ccode\u003E(row, col)\u003C/code\u003E only when the time you visit it is greater than or equal to \u003Ccode\u003Egrid[row][col]\u003C/code\u003E.\u003C/p\u003E\n\n\u003Cp\u003EYou are standing in the \u003Cstrong\u003Etop-left\u003C/strong\u003E cell of the matrix in the \u003Ccode\u003E0\u003Csup\u003Eth\u003C/sup\u003E\u003C/code\u003E second, and you must move to \u003Cstrong\u003Eany\u003C/strong\u003E adjacent cell in the four directions: up, down, left, and right. Each move you make takes 1 second.\u003C/p\u003E\n\n\u003Cp\u003EReturn \u003Cem\u003Ethe \u003Cstrong\u003Eminimum\u003C/strong\u003E time required in which you can visit the bottom-right cell of the matrix\u003C/em\u003E. If you cannot visit the bottom-right cell, then return \u003Ccode\u003E-1\u003C/code\u003E.\u003C/p\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 1:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cp\u003E\u003Cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/02/14/yetgriddrawio-8.png\" /\u003E\u003C/p\u003E\n\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E grid = [[0,1,3,2],[5,1,2,5],[4,3,8,6]]\n\u003Cstrong\u003EOutput:\u003C/strong\u003E 7\n\u003Cstrong\u003EExplanation:\u003C/strong\u003E One of the paths that we can take is the following:\n- at t = 0, we are on the cell (0,0).\n- at t = 1, we move to the cell (0,1). It is possible because grid[0][1] &lt;= 1.\n- at t = 2, we move to the cell (1,1). It is possible because grid[1][1] &lt;= 2.\n- at t = 3, we move to the cell (1,2). It is possible because grid[1][2] &lt;= 3.\n- at t = 4, we move to the cell (1,1). It is possible because grid[1][1] &lt;= 4.\n- at t = 5, we move to the cell (1,2). It is possible because grid[1][2] &lt;= 5.\n- at t = 6, we move to the cell (1,3). It is possible because grid[1][3] &lt;= 6.\n- at t = 7, we move to the cell (2,3). It is possible because grid[2][3] &lt;= 7.\nThe final time is 7. It can be shown that it is the minimum time possible.\n\u003C/pre\u003E\n\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 2:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cp\u003E\u003Cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/02/14/yetgriddrawio-9.png\" style=\"width: 151px; height: 151px;\" /\u003E\u003C/p\u003E\n\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E grid = [[0,2,4],[3,2,1],[1,0,4]]\n\u003Cstrong\u003EOutput:\u003C/strong\u003E -1\n\u003Cstrong\u003EExplanation:\u003C/strong\u003E There is no path from the top left to the bottom-right cell.\n\u003C/pre\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EConstraints:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cul\u003E\n\t\u003Cli\u003E\u003Ccode\u003Em == grid.length\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003En == grid[i].length\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E2 &lt;= m, n &lt;= 1000\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E4 &lt;= m * n &lt;= 10\u003Csup\u003E5\u003C/sup\u003E\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E0 &lt;= grid[i][j] &lt;= 10\u003Csup\u003E5\u003C/sup\u003E\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003Egrid[0][0] == 0\u003C/code\u003E\u003C/li\u003E\n\u003C/ul\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cstyle type=\"text/css\"\u003E.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; \n}\n.spoiler {overflow:hidden;}\n.spoiler \u003E div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;}\n.spoilerbutton[value=\"Show Message\"] + .spoiler \u003E div {margin-top:-500%;}\n.spoilerbutton[value=\"Hide Message\"] + .spoiler {padding:5px;}\n\u003C/style\u003E\n",
    "code": "const minimumTime \\u003D function(grid) {\\u000A  \\u000A  // store row and column lengths\\u000A  const row \\u003D grid.length, col \\u003D grid[0].length\\u000A  \\u000A  // return \\u002D1 if top\\u002Dleft cell is gridlocked\\u000A  if(grid.length \\u003E 1 \\u0026\\u0026 grid[0].length \\u003E 1 \\u0026\\u0026 grid[1][0] \\u003E 1 \\u0026\\u0026 grid[0][1] \\u003E 1) return \\u002D1\\u000A  \\u000A  // initialize dynamic programming matrix with Infinity values and set top\\u002Dleft cell to 0\\u000A  const dp \\u003D Array(grid.length).fill().map(() \\u003D\\u003E Array(grid[0].length).fill(Infinity))\\u000A  dp[0][0] \\u003D 0\\u000A  \\u000A  // initialize a minimum priority heap and an array of direction coordinates\\u000A  // add the coordinates, time and priority for start point of top\\u002Dleft cell\\u000A  const heap \\u003D  new MinPriorityQueue(), dirs \\u003D [[1,0],[\\u002D1,0],[0,1],[0,\\u002D1]]\\u000A  heap.enqueue([0,0,0],0)\\u000A  \\u000A  // iterate through heap to determine next cell with lowest time\\u000A  while(heap.size()){\\u000A    const [x,y,time] \\u003D heap.dequeue().element\\u000A    \\u000A    // if we have arrived at the end of the matrix return time value\\u000A    if(x \\u003D\\u003D row \\u002D 1 \\u0026\\u0026 y \\u003D\\u003D col \\u002D 1) return time\\u000A    \\u000A    // iterate directions and create values for possible next coordinates in our matrix\\u000A    for(const [dirX,dirY] of dirs){\\u000A      const nextX \\u003D x + dirX, nextY \\u003D y + dirY\\u000A      \\u000A      // check if next coordinates are out of bounds\\u000A      if(nextX \\u003E\\u003D 0 \\u0026\\u0026 nextY \\u003E\\u003D 0 \\u0026\\u0026 nextX \\u003C row \\u0026\\u0026 nextY \\u003C col){\\u000A        \\u000A        // since you can bounce back and fourth between prior cells to \\u000A        // reach the next value, set next time to one greater than next \\u000A        // cell value if the difference between the two values is even, \\u000A        // if the difference is not divisible by 2, set next time to the \\u000A        // max value of the next cell value and current time + 1\\u000A        const nextTime \\u003D grid[nextX][nextY] \\u003E time \\u0026\\u0026 (grid[nextX][nextY] \\u002D time) % 2 \\u003D\\u003D 0 ? grid[nextX][nextY] + 1 : Math.max(grid[nextX][nextY], time + 1)\\u000A        \\u000A        // if our next time is less than any values we\\u0027ve encountered at \\u000A        // this  location, set the dp coordinates to next time and add the \\u000A        // next coordinates and next time to the minimum priorty queue\\u000A        if(nextTime \\u003C dp[nextX][nextY]){\\u000A          dp[nextX][nextY] \\u003D nextTime\\u000A          heap.enqueue([nextX,nextY,nextTime],nextTime)\\u000A        }\\u000A      }\\u000A    }\\u000A  }\\u000A  \\u000A  // return the minimum time it took to reach the last cell\\u000A  return dp[row\\u002D1][col\\u002D1]\\u000A}\n",
    "tags": [
      "Array",
      "Breadth-First Search",
      "Graph",
      "Heap (Priority Queue)",
      "Matrix"
    ],
    "created_at": "2024-10-11T19:35:44.820Z",
    "updated_at": "2024-10-11T19:35:44.820Z"
  },
  {
    "id": 3,
    "title": "Minimum Obstacle Removal to Reach Corner",
    "content": "\u003Cp\u003EYou are given a \u003Cstrong\u003E0-indexed\u003C/strong\u003E 2D integer array \u003Ccode\u003Egrid\u003C/code\u003E of size \u003Ccode\u003Em x n\u003C/code\u003E. Each cell has one of two values:\u003C/p\u003E\n\n\u003Cul\u003E\n\t\u003Cli\u003E\u003Ccode\u003E0\u003C/code\u003E represents an \u003Cstrong\u003Eempty\u003C/strong\u003E cell,\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E1\u003C/code\u003E represents an \u003Cstrong\u003Eobstacle\u003C/strong\u003E that may be removed.\u003C/li\u003E\n\u003C/ul\u003E\n\n\u003Cp\u003EYou can move up, down, left, or right from and to an empty cell.\u003C/p\u003E\n\n\u003Cp\u003EReturn \u003Cem\u003Ethe \u003Cstrong\u003Eminimum\u003C/strong\u003E number of \u003Cstrong\u003Eobstacles\u003C/strong\u003E to \u003Cstrong\u003Eremove\u003C/strong\u003E so you can move from the upper left corner \u003C/em\u003E\u003Ccode\u003E(0, 0)\u003C/code\u003E\u003Cem\u003E to the lower right corner \u003C/em\u003E\u003Ccode\u003E(m - 1, n - 1)\u003C/code\u003E.\u003C/p\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 1:\u003C/strong\u003E\u003C/p\u003E\n\u003Cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/06/example1drawio-1.png\" style=\"width: 605px; height: 246px;\" /\u003E\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E grid = [[0,1,1],[1,1,0],[1,1,0]]\n\u003Cstrong\u003EOutput:\u003C/strong\u003E 2\n\u003Cstrong\u003EExplanation:\u003C/strong\u003E We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).\nIt can be shown that we need to remove at least 2 obstacles, so we return 2.\nNote that there may be other ways to remove 2 obstacles to create a path.\n\u003C/pre\u003E\n\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 2:\u003C/strong\u003E\u003C/p\u003E\n\u003Cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/06/example1drawio.png\" style=\"width: 405px; height: 246px;\" /\u003E\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]\n\u003Cstrong\u003EOutput:\u003C/strong\u003E 0\n\u003Cstrong\u003EExplanation:\u003C/strong\u003E We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0.\n\u003C/pre\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EConstraints:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cul\u003E\n\t\u003Cli\u003E\u003Ccode\u003Em == grid.length\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003En == grid[i].length\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E1 &lt;= m, n &lt;= 10\u003Csup\u003E5\u003C/sup\u003E\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E2 &lt;= m * n &lt;= 10\u003Csup\u003E5\u003C/sup\u003E\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003Egrid[i][j]\u003C/code\u003E is either \u003Ccode\u003E0\u003C/code\u003E \u003Cstrong\u003Eor\u003C/strong\u003E \u003Ccode\u003E1\u003C/code\u003E.\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003Egrid[0][0] == grid[m - 1][n - 1] == 0\u003C/code\u003E\u003C/li\u003E\n\u003C/ul\u003E\n",
    "code": "const minimumObstacles = function (grid) {\n  \n  // store row and column lengths\n  const row = grid.length, col = grid[0].length\n  \n  // initialize dynamic programming matrix with Infinity values and set top-left cell to 0\n  const dp = new Array(row).fill().map(() =\u003E new Array(col).fill(Infinity))\n  dp[0][0] = 0\n  \n  // initialize a minimum priority heap and an array of direction coordinates\n  // add the coordinates, time and priority for start point of top-left cell\n  const heap = new MinPriorityQueue(), dirs = [[1,0],[-1,0],[0,1],[0,-1]]\n  heap.enqueue([0,0],0)\n  \n  // iterate through heap to determine next cell with lowest obstacles removed\n  // set value for obstacles removed to initial value of top-left of dp\n  while(heap.size()){\n    const [x,y] = heap.dequeue().element, tax = dp[x][y]\n    \n    // return minimum obstacles removed once we arrive at the end of the matrix\n    if(x == row - 1 && y == col - 1) return tax\n    \n    // iterate through our directions array and create values for a possible next coordinates\n    // in our matrix, check the values to see if they are in bounds and less than the minimum \n    // obstacles removed for any other path that led us to this next coordinate, stored in dp\n    for(const [dirX, dirY] of dirs){\n      const nextX = x + dirX, nextY = y + dirY\n      if(nextX \u003E= 0 && nextY \u003E= 0 && nextX \u003C row && nextY \u003C col && tax + grid[nextX][nextY] \u003C dp[nextX][nextY]){\n        \n        // add coordinates and obstacles removed tax to queue if next coordinates pass checks\n        dp[nextX][nextY] = tax + grid[nextX][nextY]\n        heap.enqueue([nextX,nextY],tax)\n      }\n    }\n  }\n};",
    "tags": [
      "Array",
      "Breadth-First Search",
      "Graph",
      "Heap (Priority Queue)",
      "Matrix",
      "Shortest Path"
    ],
    "created_at": "2024-10-11T19:36:04.846Z",
    "updated_at": "2024-10-11T19:36:04.846Z"
  },
  {
    "id": 4,
    "title": "Binary Tree Vertical Order Traversal",
    "content": "\u003Cp\u003EGiven the \u003Ccode\u003Eroot\u003C/code\u003E of a binary tree, return \u003Cem\u003E\u003Cstrong\u003Ethe vertical order traversal\u003C/strong\u003E of its nodes&#39; values\u003C/em\u003E. (i.e., from top to bottom, column by column).\u003C/p\u003E\n\n\u003Cp\u003EIf two nodes are in the same row and column, the order should be from \u003Cstrong\u003Eleft to right\u003C/strong\u003E.\u003C/p\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 1:\u003C/strong\u003E\u003C/p\u003E\n\u003Cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/09/23/image1.png\" style=\"width: 400px; height: 273px;\" /\u003E\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E root = [3,9,20,null,null,15,7]\n\u003Cstrong\u003EOutput:\u003C/strong\u003E [[9],[3,15],[20],[7]]\n\u003C/pre\u003E\n\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 2:\u003C/strong\u003E\u003C/p\u003E\n\u003Cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/09/23/image3.png\" style=\"width: 450px; height: 285px;\" /\u003E\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E root = [3,9,8,4,0,1,7]\n\u003Cstrong\u003EOutput:\u003C/strong\u003E [[4],[9],[3,0,1],[8],[7]]\n\u003C/pre\u003E\n\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 3:\u003C/strong\u003E\u003C/p\u003E\n\u003Cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/09/23/image2.png\" style=\"width: 350px; height: 342px;\" /\u003E\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E root = [1,2,3,4,10,9,11,null,5,null,null,null,null,null,null,null,6]\n\u003Cstrong\u003EOutput:\u003C/strong\u003E [[4],[2,5],[1,10,9,6],[3],[11]]\n\u003C/pre\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EConstraints:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cul\u003E\n\t\u003Cli\u003EThe number of nodes in the tree is in the range \u003Ccode\u003E[0, 100]\u003C/code\u003E.\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E-100 &lt;= Node.val &lt;= 100\u003C/code\u003E\u003C/li\u003E\n\u003C/ul\u003E\n",
    "code": "const verticalOrder = function(root) {\n  \n  // assign map to traverse function\n  let map = traverse(root)\n  \n  // iterate through map object and return each col values \n  // from left to right after sorting each array by their row\n  return Object.values(map).map((values) =\u003E {\n    \n    // sorting by row ensures vertical order since the top most\n    // value should have the lowest row value\n    values.sort((a,b) =\u003E a[0] - b[0])\n    \n    // return only the node value and now the array\n    return values.map((val) =\u003E val[1])\n  })\n}\n\n// traverse function will traverse the tree and store the values\n// and row of the a node for a given column, initialize the row \n// to 0 for the starting node and col to 100 given that the \n// constraints are -100 \u003C= Node.val \u003C= 100, we should never \n// reach a column less than zero\nconst traverse = (node, row = 0, col = 100, map = {}) =\u003E {\n  \n  // if no node given in first call, return an empty array\n  if(!node) return []\n  \n  // initialize key of col to an empty array\n  if(!map[col]) map[col] = []\n  \n  // store row and value pair to col\n  map[col].push([row,node.val])\n  \n  // if node.left exists, recursively call with function with\n  // row + 1 (going down tree) and col - 1 (going left tree)\n  if(node.left) traverse(node.left, row + 1, col - 1, map)\n  \n  // if node.right exists, recursively call with function with\n  // row + 1 (going down tree) and col + 1 (going right tree)\n  if(node.right) traverse(node.right, row + 1, col + 1, map)\n  \n  // return map object once traversal is completed\n  return map\n}",
    "tags": [
      "Hash Table",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Sorting",
      "Binary Tree"
    ],
    "created_at": "2024-10-11T19:36:18.892Z",
    "updated_at": "2024-10-11T19:36:18.892Z"
  },
  {
    "id": 5,
    "title": "Lowest Common Ancestor of a Binary Tree III",
    "content": "\u003Cp\u003EGiven two nodes of a&nbsp;binary tree \u003Ccode\u003Ep\u003C/code\u003E and \u003Ccode\u003Eq\u003C/code\u003E, return \u003Cem\u003Etheir&nbsp;lowest common ancestor (LCA)\u003C/em\u003E.\u003C/p\u003E\n\n\u003Cp\u003EEach node will have a reference to its parent node. The definition for \u003Ccode\u003ENode\u003C/code\u003E is below:\u003C/p\u003E\n\n\u003Cpre\u003E\nclass Node {\n    public int val;\n    public Node left;\n    public Node right;\n    public Node parent;\n}\n\u003C/pre\u003E\n\n\u003Cp\u003EAccording to the \u003Cstrong\u003E\u003Ca href=\"https://en.wikipedia.org/wiki/Lowest_common_ancestor\" target=\"_blank\"\u003Edefinition of LCA on Wikipedia\u003C/a\u003E\u003C/strong\u003E: &quot;The lowest common ancestor of two nodes p and q in a tree T is the lowest node that has both p and q as descendants (where we allow \u003Cb\u003Ea node to be a descendant of itself\u003C/b\u003E).&quot;\u003C/p\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 1:\u003C/strong\u003E\u003C/p\u003E\n\u003Cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style=\"width: 200px; height: 190px;\" /\u003E\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n\u003Cstrong\u003EOutput:\u003C/strong\u003E 3\n\u003Cstrong\u003EExplanation:\u003C/strong\u003E The LCA of nodes 5 and 1 is 3.\n\u003C/pre\u003E\n\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 2:\u003C/strong\u003E\u003C/p\u003E\n\u003Cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style=\"width: 200px; height: 190px;\" /\u003E\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n\u003Cstrong\u003EOutput:\u003C/strong\u003E 5\n\u003Cstrong\u003EExplanation:\u003C/strong\u003E The LCA of nodes 5 and 4 is 5 since a node can be a descendant of itself according to the LCA definition.\n\u003C/pre\u003E\n\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 3:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E root = [1,2], p = 1, q = 2\n\u003Cstrong\u003EOutput:\u003C/strong\u003E 1\n\u003C/pre\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EConstraints:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cul\u003E\n\t\u003Cli\u003EThe number of nodes in the tree is in the range \u003Ccode\u003E[2, 10\u003Csup\u003E5\u003C/sup\u003E]\u003C/code\u003E.\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E-10\u003Csup\u003E9\u003C/sup\u003E &lt;= Node.val &lt;= 10\u003Csup\u003E9\u003C/sup\u003E\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003EAll \u003Ccode\u003ENode.val\u003C/code\u003E are \u003Cstrong\u003Eunique\u003C/strong\u003E.\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003Ep != q\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003Ep\u003C/code\u003E and \u003Ccode\u003Eq\u003C/code\u003E exist in the tree.\u003C/li\u003E\n\u003C/ul\u003E\n",
    "code": "const lowestCommonAncestor = function(p, q) {\n  \n  // initialize Set to store values we come across\n  // traversing upwards from p to root and add \n  // initial value of p node\n  const seen = new Set()\n  seen.add(p.val)\n  \n  // add the remainder of values from p to root\n  while(p.parent){\n    p = p.parent\n    seen.add(p.val)\n  }\n  \n  // if our initial q value exists in Set return value\n  if(seen.has(q.val)) return q\n  \n  // traverse upwards from q to root and return\n  // the first value that exists in Set\n  while(q.parent){\n    q = q.parent\n    if(seen.has(q.val)) return q\n  }\n}",
    "tags": [
      "Hash Table",
      "Two Pointers",
      "Tree",
      "Binary Tree"
    ],
    "created_at": "2024-10-11T19:36:29.305Z",
    "updated_at": "2024-10-11T19:36:29.305Z"
  },
  {
    "id": 6,
    "title": "Minimum Remove to Make Valid Parentheses",
    "content": "\u003Cp\u003EGiven a string \u003Cfont face=\"monospace\"\u003Es\u003C/font\u003E of \u003Ccode\u003E&#39;(&#39;\u003C/code\u003E , \u003Ccode\u003E&#39;)&#39;\u003C/code\u003E and lowercase English characters.\u003C/p\u003E\n\n\u003Cp\u003EYour task is to remove the minimum number of parentheses ( \u003Ccode\u003E&#39;(&#39;\u003C/code\u003E or \u003Ccode\u003E&#39;)&#39;\u003C/code\u003E, in any positions ) so that the resulting \u003Cem\u003Eparentheses string\u003C/em\u003E is valid and return \u003Cstrong\u003Eany\u003C/strong\u003E valid string.\u003C/p\u003E\n\n\u003Cp\u003EFormally, a \u003Cem\u003Eparentheses string\u003C/em\u003E is valid if and only if:\u003C/p\u003E\n\n\u003Cul\u003E\n\t\u003Cli\u003EIt is the empty string, contains only lowercase characters, or\u003C/li\u003E\n\t\u003Cli\u003EIt can be written as \u003Ccode\u003EAB\u003C/code\u003E (\u003Ccode\u003EA\u003C/code\u003E concatenated with \u003Ccode\u003EB\u003C/code\u003E), where \u003Ccode\u003EA\u003C/code\u003E and \u003Ccode\u003EB\u003C/code\u003E are valid strings, or\u003C/li\u003E\n\t\u003Cli\u003EIt can be written as \u003Ccode\u003E(A)\u003C/code\u003E, where \u003Ccode\u003EA\u003C/code\u003E is a valid string.\u003C/li\u003E\n\u003C/ul\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 1:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E s = &quot;lee(t(c)o)de)&quot;\n\u003Cstrong\u003EOutput:\u003C/strong\u003E &quot;lee(t(c)o)de&quot;\n\u003Cstrong\u003EExplanation:\u003C/strong\u003E &quot;lee(t(co)de)&quot; , &quot;lee(t(c)ode)&quot; would also be accepted.\n\u003C/pre\u003E\n\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 2:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E s = &quot;a)b(c)d&quot;\n\u003Cstrong\u003EOutput:\u003C/strong\u003E &quot;ab(c)d&quot;\n\u003C/pre\u003E\n\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 3:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E s = &quot;))((&quot;\n\u003Cstrong\u003EOutput:\u003C/strong\u003E &quot;&quot;\n\u003Cstrong\u003EExplanation:\u003C/strong\u003E An empty string is also valid.\n\u003C/pre\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EConstraints:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cul\u003E\n\t\u003Cli\u003E\u003Ccode\u003E1 &lt;= s.length &lt;= 10\u003Csup\u003E5\u003C/sup\u003E\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003Es[i]\u003C/code\u003E is either&nbsp;\u003Ccode\u003E&#39;(&#39;\u003C/code\u003E , \u003Ccode\u003E&#39;)&#39;\u003C/code\u003E, or lowercase English letter.\u003C/li\u003E\n\u003C/ul\u003E\n",
    "code": "const minRemoveToMakeValid = function(s) {\n  \n  // intialize stacks for open and closed parentheses\n  const open = [], closed = []\n  \n  // iterate through string and store open and closed\n  // parentheses, whenever you encounter a closed\n  // parentheses with an open one existing in the open\n  // stack, remove the last element from the stack and\n  // do not store the closed parenteses\n  for(i = 0; i \u003C s.length; i++){\n    if(s[i] == '('){\n      open.push(s[i])\n    }else if(s[i] == ')' && open.length){\n      open.pop()\n    }else if(s[i] == ')'){\n      closed.push(s[i])\n    }\n  }\n  \n  // if open and closed stacks are empty there are\n  // no parentheses to remove so return s\n  if(!open.length && !closed.length) return s\n  \n  // if the string length equals all stored parentheses you\n  // must remove all ie \"))((\" and return an empty string\n  if(open.length + closed.length == s.length) return \"\"\n  \n  // as long as the stacks have values, iterate through\n  // string from left to remove the first closed\n  // parentheses you encounter and from the right to \n  // remove the first open parentheses you encounter\n  let start = 0, end = s.length - 1\n  while(closed.length){\n    if(s[start] == ')' && closed.length){\n      closed.pop()\n      s = s.slice(0, start) + s.slice(start + 1)\n    }else{\n      start++\n    }\n  }\n  while(open.length){\n    if(s[end] == '(' && open.length){\n      open.pop()    \n      s = s.slice(0, end) + s.slice(end + 1)\n    }else{\n      end--\n    }\n  }   \n  return s\n}",
    "tags": [
      "String",
      "Stack"
    ],
    "created_at": "2024-10-11T19:36:42.370Z",
    "updated_at": "2024-10-11T19:36:42.370Z"
  },
  {
    "id": 7,
    "title": "Basic Calculator II",
    "content": "\u003Cp\u003EGiven a string \u003Ccode\u003Es\u003C/code\u003E which represents an expression, \u003Cem\u003Eevaluate this expression and return its value\u003C/em\u003E.&nbsp;\u003C/p\u003E\n\n\u003Cp\u003EThe integer division should truncate toward zero.\u003C/p\u003E\n\n\u003Cp\u003EYou may assume that the given expression is always valid. All intermediate results will be in the range of \u003Ccode\u003E[-2\u003Csup\u003E31\u003C/sup\u003E, 2\u003Csup\u003E31\u003C/sup\u003E - 1]\u003C/code\u003E.\u003C/p\u003E\n\n\u003Cp\u003E\u003Cstrong\u003ENote:\u003C/strong\u003E You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as \u003Ccode\u003Eeval()\u003C/code\u003E.\u003C/p\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 1:\u003C/strong\u003E\u003C/p\u003E\n\u003Cpre\u003E\u003Cstrong\u003EInput:\u003C/strong\u003E s = \"3+2*2\"\n\u003Cstrong\u003EOutput:\u003C/strong\u003E 7\n\u003C/pre\u003E\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 2:\u003C/strong\u003E\u003C/p\u003E\n\u003Cpre\u003E\u003Cstrong\u003EInput:\u003C/strong\u003E s = \" 3/2 \"\n\u003Cstrong\u003EOutput:\u003C/strong\u003E 1\n\u003C/pre\u003E\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 3:\u003C/strong\u003E\u003C/p\u003E\n\u003Cpre\u003E\u003Cstrong\u003EInput:\u003C/strong\u003E s = \" 3+5 / 2 \"\n\u003Cstrong\u003EOutput:\u003C/strong\u003E 5\n\u003C/pre\u003E\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EConstraints:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cul\u003E\n\t\u003Cli\u003E\u003Ccode\u003E1 &lt;= s.length &lt;= 3 * 10\u003Csup\u003E5\u003C/sup\u003E\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003Es\u003C/code\u003E consists of integers and operators \u003Ccode\u003E(&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;)\u003C/code\u003E separated by some number of spaces.\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003Es\u003C/code\u003E represents \u003Cstrong\u003Ea valid expression\u003C/strong\u003E.\u003C/li\u003E\n\t\u003Cli\u003EAll the integers in the expression are non-negative integers in the range \u003Ccode\u003E[0, 2\u003Csup\u003E31\u003C/sup\u003E - 1]\u003C/code\u003E.\u003C/li\u003E\n\t\u003Cli\u003EThe answer is \u003Cstrong\u003Eguaranteed\u003C/strong\u003E to fit in a \u003Cstrong\u003E32-bit integer\u003C/strong\u003E.\u003C/li\u003E\n\u003C/ul\u003E\n",
    "code": "const calculate = function(s) {\n  let cur = ''\n  let sym = '+'\n  const stack = []\n  for(const char of s){\n    if(Number.isInteger(Number(char))){\n      cur += char\n    }else{\n      stack.push(handleArithmetic(sym, cur, stack))\n      cur = ''\n      sym = char\n    }\n  }\n  stack.push(handleArithmetic(sym, cur, stack))\n  return stack.reduce((a,b) =\u003E a + b)\n}\n\nconst handleArithmetic = (sym, cur, stack) =\u003E {\n  if(sym == '+') return Number(cur)\n  if(sym == '-') return -Number(cur)\n  if(sym == '*') return stack.pop() * Number(cur)\n  if(sym == '/') return Math.trunc(stack.pop() / Number(cur))\n}",
    "tags": [
      "String",
      "Stack",
      "Math"
    ],
    "created_at": "2024-10-11T19:36:53.555Z",
    "updated_at": "2024-10-11T19:36:53.555Z"
  },
  {
    "id": 8,
    "title": "Revenue Milestones",
    "content": "\u003Cp\u003EWe keep track of the revenue Facebook makes every day, and we want to know on what days Facebook hits certain revenue milestones. Given an array of the revenue on each day, and an array of milestones Facebook wants to reach, return an array containing the days on which Facebook reached every milestone.\u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003E Signature \u003C/strong\u003E\u003C/p\u003Eint[] getMilestoneDays(int[] revenues, int[] milestones)\u003Cp\u003E\u003Cstrong\u003EInput \u003C/strong\u003E\u003C/p\u003E\u003Cp\u003Erevenues is a length-N array representing how much revenue FB made on each day (from day 1 to day N). milestones is a length-K array of total revenue milestones.\u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003EOutput \u003C/strong\u003E\u003C/p\u003E\u003Cp\u003EReturn a length-K array where K_i is the day on which FB first had milestones[i] total revenue. If the milestone is never met, return -1.\u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003EExample \u003C/strong\u003E\u003C/p\u003E\u003Cp\u003Erevenues = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]milestones = [100, 200, 500]output = [4, 6, 10]\u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003EExplanation \u003C/strong\u003E\u003C/p\u003E\u003Cp\u003EOn days 4, 5, and 6, FB has total revenue of $100, $150, and $210 respectively. Day 6 is the first time that FB has \u003E= $200 of total revenue.\u003C/p\u003E",
    "code": "// binary Search Function to find the first revenue that hits the given milestone\nconst searchRevenues = (revenues, milestone) =\u003E {\n  let left = 0, right = revenues.length - 1\n  while(left \u003C= right){\n    let mid = Math.floor((left + right) / 2)\n    if(revenues[mid] \u003E= milestone && revenues[mid-1] \u003C milestone) return mid + 1\n    if(revenues[mid] \u003E milestone){\n      right = mid - 1\n    }else{\n      left = mid + 1\n    }\n  }\n  return -1\n}\n\n\nconst getMilestoneDays = (revenues, milestones) =\u003E {\n  \n  // add previous revenue to current value\n  for(let i = 1; i \u003C revenues.length; i++){\n    revenues[i] = revenues[i] + revenues[i - 1]\n  }\n  \n  // reassign each milestone value to the result of binary search for the\n  // first day that milestone is reached\n  for(let i = 0; i \u003C milestones.length; i++){\n    milestones[i] = searchRevenues(revenues, milestones[i])\n  }\n  return milestones\n}\n",
    "tags": [
      "Array",
      "Binary Search"
    ],
    "created_at": "2024-10-11T19:37:03.981Z",
    "updated_at": "2024-10-11T19:37:03.981Z"
  },
  {
    "id": 9,
    "title": "Making A Large Island",
    "content": "\u003Cp\u003EYou are given an \u003Ccode\u003En x n\u003C/code\u003E binary matrix \u003Ccode\u003Egrid\u003C/code\u003E. You are allowed to change \u003Cstrong\u003Eat most one\u003C/strong\u003E \u003Ccode\u003E0\u003C/code\u003E to be \u003Ccode\u003E1\u003C/code\u003E.\u003C/p\u003E\n\n\u003Cp\u003EReturn \u003Cem\u003Ethe size of the largest \u003Cstrong\u003Eisland\u003C/strong\u003E in\u003C/em\u003E \u003Ccode\u003Egrid\u003C/code\u003E \u003Cem\u003Eafter applying this operation\u003C/em\u003E.\u003C/p\u003E\n\n\u003Cp\u003EAn \u003Cstrong\u003Eisland\u003C/strong\u003E is a 4-directionally connected group of \u003Ccode\u003E1\u003C/code\u003Es.\u003C/p\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 1:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E grid = [[1,0],[0,1]]\n\u003Cstrong\u003EOutput:\u003C/strong\u003E 3\n\u003Cstrong\u003EExplanation:\u003C/strong\u003E Change one 0 to 1 and connect two 1s, then we get an island with area = 3.\n\u003C/pre\u003E\n\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 2:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E grid = [[1,1],[1,0]]\n\u003Cstrong\u003EOutput:\u003C/strong\u003E 4\n\u003Cstrong\u003EExplanation: \u003C/strong\u003EChange the 0 to 1 and make the island bigger, only one island with area = 4.\u003C/pre\u003E\n\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 3:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E grid = [[1,1],[1,1]]\n\u003Cstrong\u003EOutput:\u003C/strong\u003E 4\n\u003Cstrong\u003EExplanation:\u003C/strong\u003E Can&#39;t change any 0 to 1, only one island with area = 4.\n\u003C/pre\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EConstraints:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cul\u003E\n\t\u003Cli\u003E\u003Ccode\u003En == grid.length\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003En == grid[i].length\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E1 &lt;= n &lt;= 500\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003Egrid[i][j]\u003C/code\u003E is either \u003Ccode\u003E0\u003C/code\u003E or \u003Ccode\u003E1\u003C/code\u003E.\u003C/li\u003E\n\u003C/ul\u003E\n",
    "code": "const largestIsland = (grid) =\u003E {\n  \n  // ititialize a map object and 4 directional array\n  const map = {}, directions = [[1,0],[-1,0],[0,1],[0,-1]]\n  \n  // initialize a key to 2 so we are able to store the island\n  // sizes, we don't use 1 since the island values begin with 1\n  let key = 2\n  \n  // iterate through each cell and run the mapIsland helper\n  // function to update the map object with the island sizes\n  // based on the key value then increment the key value\n  for(let i = 0; i \u003C grid.length; i++){\n    for(let j = 0; j \u003C grid[0].length; j++){\n      if(grid[i][j] == 1 && !map[key]){\n        mapIsland(map, grid, directions, i, j, key)\n        key++\n      }\n    }\n  }\n  \n  // initialize our max to 0 then update the max value to the\n  // largest island we currently have stored in map\n  let max = 0\n  Object.values(map).map((val) =\u003E max = Math.max(max, val))\n  \n  // iterate through each cell and run the calcLargest helper\n  // function to update the max to the largest possible combination\n  for(let i = 0; i \u003C grid.length; i++){\n    for(let j = 0; j \u003C grid[0].length; j++){\n      if(grid[i][j] == 0){\n        max = Math.max(max, calcLargest(map, grid, directions, i, j))\n      }\n    }\n  }\n  return max\n}\n\nconst mapIsland = (map, grid, directions, x, y, key) =\u003E {\n  // initialize our queue with the current coordinates and set\n  // the cell value to the current key value and initialize the\n  // total value to 1 to account for our current cell\n  const q = [[x,y]]\n  grid[x][y] = key\n  let total = 1\n  \n  // iterate through the queue to map the island\n  while(q.length){\n    const [currentX, currentY] = q.shift()\n    \n    // create values for possible next coordinates in the matrix\n    // check the values to see if they are in bounds and not 0\n    for(const [directionX, directionY] of directions){\n      const nextX = currentX + directionX, nextY = currentY + directionY\n      if(nextX \u003C grid.length && nextX \u003E= 0 && nextY \u003C grid[0].length && nextY \u003E= 0 && grid[nextX][nextY] == 1){\n        \n        // if checks pass, set the cell to key value, increment total and\n        // push the next coordinates of the island to the queue\n        grid[nextX][nextY] = key\n        total++\n        q.push([nextX,nextY])\n      }\n    }\n  }\n  \n  // assign the total size of our island to the key value in map\n  map[key] = total\n}\n\nconst calcLargest = (map, grid, directions, x, y) =\u003E {\n  \n  // set the total to 1 to account for changing the current cell to 1\n  // initialize a new Set to hold key values for islands already seen\n  let total = 1, seen = new Set()\n  \n  // create values for possible next coordinates in the matrix\n  // check the values to see if they are in bounds, not 0 and unseen\n  for(const [directionX, directionY] of directions){\n    const nextX = x + directionX, nextY = y + directionY\n    if(nextX \u003C grid.length && nextX \u003E= 0 && nextY \u003C grid[0].length && nextY \u003E= 0 && grid[nextX][nextY] != 0 && !seen.has(grid[nextX][nextY])){\n      \n      // add the value of the island to the total and add the island to seen\n      total += map[grid[nextX][nextY]]\n      seen.add(grid[nextX][nextY])\n    }\n  }\n  \n  // return total size of combinding islands\n  return total\n}",
    "tags": [
      "Array",
      "Matrix",
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find"
    ],
    "created_at": "2024-10-11T19:37:13.978Z",
    "updated_at": "2024-10-11T19:37:13.978Z"
  },
  {
    "id": 10,
    "title": "Interval List Intersections",
    "content": "\u003Cp\u003EYou are given two lists of closed intervals, \u003Ccode\u003EfirstList\u003C/code\u003E and \u003Ccode\u003EsecondList\u003C/code\u003E, where \u003Ccode\u003EfirstList[i] = [start\u003Csub\u003Ei\u003C/sub\u003E, end\u003Csub\u003Ei\u003C/sub\u003E]\u003C/code\u003E and \u003Ccode\u003EsecondList[j] = [start\u003Csub\u003Ej\u003C/sub\u003E, end\u003Csub\u003Ej\u003C/sub\u003E]\u003C/code\u003E. Each list of intervals is pairwise \u003Cstrong\u003Edisjoint\u003C/strong\u003E and in \u003Cstrong\u003Esorted order\u003C/strong\u003E.\u003C/p\u003E\n\n\u003Cp\u003EReturn \u003Cem\u003Ethe intersection of these two interval lists\u003C/em\u003E.\u003C/p\u003E\n\n\u003Cp\u003EA \u003Cstrong\u003Eclosed interval\u003C/strong\u003E \u003Ccode\u003E[a, b]\u003C/code\u003E (with \u003Ccode\u003Ea &lt;= b\u003C/code\u003E) denotes the set of real numbers \u003Ccode\u003Ex\u003C/code\u003E with \u003Ccode\u003Ea &lt;= x &lt;= b\u003C/code\u003E.\u003C/p\u003E\n\n\u003Cp\u003EThe \u003Cstrong\u003Eintersection\u003C/strong\u003E of two closed intervals is a set of real numbers that are either empty or represented as a closed interval. For example, the intersection of \u003Ccode\u003E[1, 3]\u003C/code\u003E and \u003Ccode\u003E[2, 4]\u003C/code\u003E is \u003Ccode\u003E[2, 3]\u003C/code\u003E.\u003C/p\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 1:\u003C/strong\u003E\u003C/p\u003E\n\u003Cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/30/interval1.png\" style=\"width: 700px; height: 194px;\" /\u003E\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]\n\u003Cstrong\u003EOutput:\u003C/strong\u003E [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]\n\u003C/pre\u003E\n\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 2:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E firstList = [[1,3],[5,9]], secondList = []\n\u003Cstrong\u003EOutput:\u003C/strong\u003E []\n\u003C/pre\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EConstraints:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cul\u003E\n\t\u003Cli\u003E\u003Ccode\u003E0 &lt;= firstList.length, secondList.length &lt;= 1000\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003EfirstList.length + secondList.length &gt;= 1\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E0 &lt;= start\u003Csub\u003Ei\u003C/sub\u003E &lt; end\u003Csub\u003Ei\u003C/sub\u003E &lt;= 10\u003Csup\u003E9\u003C/sup\u003E\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003Eend\u003Csub\u003Ei\u003C/sub\u003E &lt; start\u003Csub\u003Ei+1\u003C/sub\u003E\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E0 &lt;= start\u003Csub\u003Ej\u003C/sub\u003E &lt; end\u003Csub\u003Ej\u003C/sub\u003E &lt;= 10\u003Csup\u003E9\u003C/sup\u003E \u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003Eend\u003Csub\u003Ej\u003C/sub\u003E &lt; start\u003Csub\u003Ej+1\u003C/sub\u003E\u003C/code\u003E\u003C/li\u003E\n\u003C/ul\u003E\n",
    "code": "const intervalIntersection = function(firstList, secondList) {\n  const result = []\n  \n  // iterate first and second list then check to see if an\n  // intersection exist. Call the helper function to calculate\n  // the intersection and push return value to result\n  for(const [a1, b1] of firstList){\n    for(const [a2, b2] of secondList){\n      if((a1 \u003E b2) || (b1 \u003C a2)) continue\n      if(checkIntersection([a1, b1],[a2, b2])){\n        result.push(calcIntersection([a1, b1],[a2, b2]))\n      } \n    }\n  }\n  return result\n}\n\nconst checkIntersection = (first, second) =\u003E {\n  const [a1, b1] = first, [a2, b2] = second\n  \n  // check if there is any overlap in the intervals\n  if(\n    (a1 \u003C= a2 && a2 \u003C= b1) || \n    (a2 \u003C= a1 && a1 \u003C= b2) || \n    (a1 \u003E= a2 && b1 \u003C= b2) || \n    (a2 \u003E= a1 && b2 \u003C= b1)\n  ) return true\n  return false\n}\n\nconst calcIntersection = (first, second) =\u003E {\n  const [a1, b1] = first, [a2, b2] = second\n  \n  // return the minimum start and maximum end of\n  // the combination of the two intervals\n  return [Math.max(a1,a2), Math.min(b1,b2)]\n}",
    "tags": [
      "Array",
      "Two Pointers"
    ],
    "created_at": "2024-10-11T19:37:27.192Z",
    "updated_at": "2024-10-11T19:37:27.192Z"
  },
  {
    "id": 11,
    "title": "Binary Tree Right Side View",
    "content": "\u003Cp\u003EGiven the \u003Ccode\u003Eroot\u003C/code\u003E of a binary tree, imagine yourself standing on the \u003Cstrong\u003Eright side\u003C/strong\u003E of it, return \u003Cem\u003Ethe values of the nodes you can see ordered from top to bottom\u003C/em\u003E.\u003C/p\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 1:\u003C/strong\u003E\u003C/p\u003E\n\u003Cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/14/tree.jpg\" style=\"width: 401px; height: 301px;\" /\u003E\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E root = [1,2,3,null,5,null,4]\n\u003Cstrong\u003EOutput:\u003C/strong\u003E [1,3,4]\n\u003C/pre\u003E\n\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 2:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E root = [1,null,3]\n\u003Cstrong\u003EOutput:\u003C/strong\u003E [1,3]\n\u003C/pre\u003E\n\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 3:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E root = []\n\u003Cstrong\u003EOutput:\u003C/strong\u003E []\n\u003C/pre\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EConstraints:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cul\u003E\n\t\u003Cli\u003EThe number of nodes in the tree is in the range \u003Ccode\u003E[0, 100]\u003C/code\u003E.\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E-100 &lt;= Node.val &lt;= 100\u003C/code\u003E\u003C/li\u003E\n\u003C/ul\u003E\n",
    "code": "const rightSideView = (root) =\u003E {\n  \n  // initialize a map object to hold an array of values of\n  // each node at a given level in the tree and a result \n  // array to hold the last value of each of those arrays\n  const map = {}, result = []\n  \n  // recursively traverse through the tree, prioritizing the \n  // left side first to ensure the last value to the right\n  // on each level is the last value pushed to the level array\n  const traverse = (root, level = 1) =\u003E {\n    if(!root) return \n    if(!map[level]) map[level] = []\n    map[level].push(root.val)\n    if(root.left) traverse(root.left, level + 1)\n    if(root.right) traverse(root.right, level + 1)\n  }\n  traverse(root)\n  \n  // remove the last value from each level array and add to result\n  Object.values(map).forEach((val) =\u003E {\n    result.push(val.pop())\n  })\n  return result\n}",
    "tags": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "created_at": "2024-10-11T19:37:42.044Z",
    "updated_at": "2024-10-11T19:37:42.044Z"
  },
  {
    "id": 12,
    "title": "Sum Root to Leaf Numbers",
    "content": "\u003Cp\u003EYou are given the \u003Ccode\u003Eroot\u003C/code\u003E of a binary tree containing digits from \u003Ccode\u003E0\u003C/code\u003E to \u003Ccode\u003E9\u003C/code\u003E only.\u003C/p\u003E\n\n\u003Cp\u003EEach root-to-leaf path in the tree represents a number.\u003C/p\u003E\n\n\u003Cul\u003E\n\t\u003Cli\u003EFor example, the root-to-leaf path \u003Ccode\u003E1 -&gt; 2 -&gt; 3\u003C/code\u003E represents the number \u003Ccode\u003E123\u003C/code\u003E.\u003C/li\u003E\n\u003C/ul\u003E\n\n\u003Cp\u003EReturn \u003Cem\u003Ethe total sum of all root-to-leaf numbers\u003C/em\u003E. Test cases are generated so that the answer will fit in a \u003Cstrong\u003E32-bit\u003C/strong\u003E integer.\u003C/p\u003E\n\n\u003Cp\u003EA \u003Cstrong\u003Eleaf\u003C/strong\u003E node is a node with no children.\u003C/p\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 1:\u003C/strong\u003E\u003C/p\u003E\n\u003Cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg\" style=\"width: 212px; height: 182px;\" /\u003E\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E root = [1,2,3]\n\u003Cstrong\u003EOutput:\u003C/strong\u003E 25\n\u003Cstrong\u003EExplanation:\u003C/strong\u003E\nThe root-to-leaf path \u003Ccode\u003E1-&gt;2\u003C/code\u003E represents the number \u003Ccode\u003E12\u003C/code\u003E.\nThe root-to-leaf path \u003Ccode\u003E1-&gt;3\u003C/code\u003E represents the number \u003Ccode\u003E13\u003C/code\u003E.\nTherefore, sum = 12 + 13 = \u003Ccode\u003E25\u003C/code\u003E.\n\u003C/pre\u003E\n\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 2:\u003C/strong\u003E\u003C/p\u003E\n\u003Cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg\" style=\"width: 292px; height: 302px;\" /\u003E\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E root = [4,9,0,5,1]\n\u003Cstrong\u003EOutput:\u003C/strong\u003E 1026\n\u003Cstrong\u003EExplanation:\u003C/strong\u003E\nThe root-to-leaf path \u003Ccode\u003E4-&gt;9-&gt;5\u003C/code\u003E represents the number 495.\nThe root-to-leaf path \u003Ccode\u003E4-&gt;9-&gt;1\u003C/code\u003E represents the number 491.\nThe root-to-leaf path \u003Ccode\u003E4-&gt;0\u003C/code\u003E represents the number 40.\nTherefore, sum = 495 + 491 + 40 = \u003Ccode\u003E1026\u003C/code\u003E.\n\u003C/pre\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EConstraints:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cul\u003E\n\t\u003Cli\u003EThe number of nodes in the tree is in the range \u003Ccode\u003E[1, 1000]\u003C/code\u003E.\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E0 &lt;= Node.val &lt;= 9\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003EThe depth of the tree will not exceed \u003Ccode\u003E10\u003C/code\u003E.\u003C/li\u003E\n\u003C/ul\u003E\n",
    "code": "const sumNumbers = function(root, str = '', sum = 0) {\n  \n  // if no root return 0 as sum\n  if(!root) return 0\n  \n  // append the current node val to the end string\n  str += root.val\n  \n  // if a leaf is reached, add string as a number to the sum and return sum\n  if(!root.left && !root.right){\n    sum += Number(str)\n    return sum\n  }\n  \n  // return the sum of traversing left and right down tree\n  return sumNumbers(root.left, str, sum) + sumNumbers(root.right, str, sum)\n}",
    "tags": [
      "Depth-First Search",
      "Tree",
      "Binary Tree"
    ],
    "created_at": "2024-10-11T19:37:52.414Z",
    "updated_at": "2024-10-11T19:37:52.414Z"
  },
  {
    "id": 13,
    "title": "Group Shifted Strings",
    "content": "\u003Cp\u003EPerform the following shift operations on a string:\u003C/p\u003E\n\n\u003Cul\u003E\n\t\u003Cli\u003E\u003Cstrong\u003ERight shift\u003C/strong\u003E: Replace every letter with the \u003Cstrong\u003Esuccessive\u003C/strong\u003E letter of the English alphabet, where &#39;z&#39; is replaced by &#39;a&#39;. For example, \u003Ccode\u003E&quot;abc&quot;\u003C/code\u003E can be right-shifted to \u003Ccode\u003E&quot;bcd&quot; \u003C/code\u003Eor \u003Ccode\u003E&quot;xyz&quot;\u003C/code\u003E can be right-shifted to \u003Ccode\u003E&quot;yza&quot;\u003C/code\u003E.\u003C/li\u003E\n\t\u003Cli\u003E\u003Cstrong\u003ELeft shift\u003C/strong\u003E: Replace every letter with the \u003Cstrong\u003Epreceding\u003C/strong\u003E letter of the English alphabet, where &#39;a&#39; is replaced by &#39;z&#39;. For example, \u003Ccode\u003E&quot;bcd&quot;\u003C/code\u003E can be left-shifted to \u003Ccode\u003E&quot;abc&quot;\u003Cfont face=\"Times New Roman\"\u003E or \u003C/font\u003E\u003C/code\u003E\u003Ccode\u003E&quot;yza&quot;\u003C/code\u003E can be left-shifted to \u003Ccode\u003E&quot;xyz&quot;\u003C/code\u003E.\u003C/li\u003E\n\u003C/ul\u003E\n\n\u003Cp\u003EWe can keep shifting the string in both directions to form an \u003Cstrong\u003Eendless\u003C/strong\u003E \u003Cstrong\u003Eshifting sequence\u003C/strong\u003E.\u003C/p\u003E\n\n\u003Cul\u003E\n\t\u003Cli\u003EFor example, shift \u003Ccode\u003E&quot;abc&quot;\u003C/code\u003E to form the sequence: \u003Ccode\u003E... &lt;-&gt; &quot;abc&quot; &lt;-&gt; &quot;bcd&quot; &lt;-&gt; ... &lt;-&gt; &quot;xyz&quot; &lt;-&gt; &quot;yza&quot; &lt;-&gt; ...\u003C/code\u003E.\u003Ccode\u003E &lt;-&gt; &quot;zab&quot; &lt;-&gt; &quot;abc&quot; &lt;-&gt; ...\u003C/code\u003E\u003C/li\u003E\n\u003C/ul\u003E\n\n\u003Cp\u003EYou are given an array of strings \u003Ccode\u003Estrings\u003C/code\u003E, group together all \u003Ccode\u003Estrings[i]\u003C/code\u003E that belong to the same shifting sequence. You may return the answer in \u003Cstrong\u003Eany order\u003C/strong\u003E.\u003C/p\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 1:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cdiv class=\"example-block\"\u003E\n\u003Cp\u003E\u003Cstrong\u003EInput:\u003C/strong\u003E \u003Cspan class=\"example-io\"\u003Estrings = [&quot;abc&quot;,&quot;bcd&quot;,&quot;acef&quot;,&quot;xyz&quot;,&quot;az&quot;,&quot;ba&quot;,&quot;a&quot;,&quot;z&quot;]\u003C/span\u003E\u003C/p\u003E\n\n\u003Cp\u003E\u003Cstrong\u003EOutput:\u003C/strong\u003E \u003Cspan class=\"example-io\"\u003E[[&quot;acef&quot;],[&quot;a&quot;,&quot;z&quot;],[&quot;abc&quot;,&quot;bcd&quot;,&quot;xyz&quot;],[&quot;az&quot;,&quot;ba&quot;]]\u003C/span\u003E\u003C/p\u003E\n\u003C/div\u003E\n\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 2:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cdiv class=\"example-block\"\u003E\n\u003Cp\u003E\u003Cstrong\u003EInput:\u003C/strong\u003E \u003Cspan class=\"example-io\"\u003Estrings = [&quot;a&quot;]\u003C/span\u003E\u003C/p\u003E\n\n\u003Cp\u003E\u003Cstrong\u003EOutput:\u003C/strong\u003E \u003Cspan class=\"example-io\"\u003E[[&quot;a&quot;]]\u003C/span\u003E\u003C/p\u003E\n\u003C/div\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EConstraints:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cul\u003E\n\t\u003Cli\u003E\u003Ccode\u003E1 &lt;= strings.length &lt;= 200\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E1 &lt;= strings[i].length &lt;= 50\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003Estrings[i]\u003C/code\u003E consists of lowercase English letters.\u003C/li\u003E\n\u003C/ul\u003E\n",
    "code": "const groupStrings = function(strings) {\n  \n  // initialize a new Map to hold equal sequences\n  const map = new Map()\n  \n  // add each string to the array of its sequence\n  for(const s of strings){\n    const key = getSeq(s)\n    if(!map.has(key)) map.set(key, [])\n    map.get(key).push(s)\n  }\n  \n  // return the values of the arrays as an array\n  return Array.from(map.values())\n}\n\nconst getSeq = (str) =\u003E {\n  \n  // start the sequence with 1 and add the difference\n  // between each character ie. f - a = 6 - 1\n  let shift = '1'\n  for(let i = 1; i \u003C str.length; i++){\n    let diff = str.charCodeAt(i) - str.charCodeAt(i - 1)\n    \n    // if our difference is less than zero, add 26 to it\n    // for cases going backwards, a - f = 1 - 6 \n    // append the difference to our sequence string\n    if(diff \u003C 0) diff += 26\n    shift += ',' + diff\n  }\n  \n  // return the sequence to be used for its key\n  return shift\n}",
    "tags": [
      "Hash Table",
      "Array",
      "String"
    ],
    "created_at": "2024-10-11T19:38:06.481Z",
    "updated_at": "2024-10-11T19:38:06.481Z"
  },
  {
    "id": 14,
    "title": "Merge k Sorted Lists",
    "content": "\u003Cp\u003EYou are given an array of \u003Ccode\u003Ek\u003C/code\u003E linked-lists \u003Ccode\u003Elists\u003C/code\u003E, each linked-list is sorted in ascending order.\u003C/p\u003E\n\n\u003Cp\u003E\u003Cem\u003EMerge all the linked-lists into one sorted linked-list and return it.\u003C/em\u003E\u003C/p\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 1:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E lists = [[1,4,5],[1,3,4],[2,6]]\n\u003Cstrong\u003EOutput:\u003C/strong\u003E [1,1,2,3,4,4,5,6]\n\u003Cstrong\u003EExplanation:\u003C/strong\u003E The linked-lists are:\n[\n  1-&gt;4-&gt;5,\n  1-&gt;3-&gt;4,\n  2-&gt;6\n]\nmerging them into one sorted list:\n1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6\n\u003C/pre\u003E\n\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 2:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E lists = []\n\u003Cstrong\u003EOutput:\u003C/strong\u003E []\n\u003C/pre\u003E\n\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 3:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E lists = [[]]\n\u003Cstrong\u003EOutput:\u003C/strong\u003E []\n\u003C/pre\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EConstraints:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cul\u003E\n\t\u003Cli\u003E\u003Ccode\u003Ek == lists.length\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E0 &lt;= k &lt;= 10\u003Csup\u003E4\u003C/sup\u003E\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E0 &lt;= lists[i].length &lt;= 500\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E-10\u003Csup\u003E4\u003C/sup\u003E &lt;= lists[i][j] &lt;= 10\u003Csup\u003E4\u003C/sup\u003E\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003Elists[i]\u003C/code\u003E is sorted in \u003Cstrong\u003Eascending order\u003C/strong\u003E.\u003C/li\u003E\n\t\u003Cli\u003EThe sum of \u003Ccode\u003Elists[i].length\u003C/code\u003E will not exceed \u003Ccode\u003E10\u003Csup\u003E4\u003C/sup\u003E\u003C/code\u003E.\u003C/li\u003E\n\u003C/ul\u003E\n",
    "code": "const mergeKLists = function(lists) {\n  \n  // initialize an object to hold values and their counts\n  // the object will inherently hold the keys as sorted\n  const map = {}\n  \n  // iterate each list and increment its value in map\n  for(let i = 0; i \u003C lists.length; i++){\n    let list = lists[i]\n    while(list){\n      let num = list.val + 10000\n      if(!map[num]) map[num] = 0\n      map[num]++\n      list = list.next\n    }\n  }\n  \n  // initialize our merged list and let dummmy equal merged\n  const merged = new ListNode()\n  let dummy = merged\n  \n  // map through our keys and add the key as a number to the\n  // merged list while decrementing the value in map\n  Object.keys(map).map((key) =\u003E {\n    let count = map[key]\n    while(count \u003E 0){\n      dummy.next = new ListNode(Number(key) - 10000)\n      dummy = dummy.next\n      count--\n    }\n  })\n  return merged.next\n}",
    "tags": [
      "Linked List",
      "Divide and Conquer",
      "Heap (Priority Queue)",
      "Merge Sort"
    ],
    "created_at": "2024-10-11T19:38:17.282Z",
    "updated_at": "2024-10-11T19:38:17.282Z"
  },
  {
    "id": 15,
    "title": "Top K Frequent Elements",
    "content": "\u003Cp\u003EGiven an integer array \u003Ccode\u003Enums\u003C/code\u003E and an integer \u003Ccode\u003Ek\u003C/code\u003E, return \u003Cem\u003Ethe\u003C/em\u003E \u003Ccode\u003Ek\u003C/code\u003E \u003Cem\u003Emost frequent elements\u003C/em\u003E. You may return the answer in \u003Cstrong\u003Eany order\u003C/strong\u003E.\u003C/p\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 1:\u003C/strong\u003E\u003C/p\u003E\n\u003Cpre\u003E\u003Cstrong\u003EInput:\u003C/strong\u003E nums = [1,1,1,2,2,3], k = 2\n\u003Cstrong\u003EOutput:\u003C/strong\u003E [1,2]\n\u003C/pre\u003E\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 2:\u003C/strong\u003E\u003C/p\u003E\n\u003Cpre\u003E\u003Cstrong\u003EInput:\u003C/strong\u003E nums = [1], k = 1\n\u003Cstrong\u003EOutput:\u003C/strong\u003E [1]\n\u003C/pre\u003E\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EConstraints:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cul\u003E\n\t\u003Cli\u003E\u003Ccode\u003E1 &lt;= nums.length &lt;= 10\u003Csup\u003E5\u003C/sup\u003E\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E-10\u003Csup\u003E4\u003C/sup\u003E &lt;= nums[i] &lt;= 10\u003Csup\u003E4\u003C/sup\u003E\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003Ek\u003C/code\u003E is in the range \u003Ccode\u003E[1, the number of unique elements in the array]\u003C/code\u003E.\u003C/li\u003E\n\t\u003Cli\u003EIt is \u003Cstrong\u003Eguaranteed\u003C/strong\u003E that the answer is \u003Cstrong\u003Eunique\u003C/strong\u003E.\u003C/li\u003E\n\u003C/ul\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EFollow up:\u003C/strong\u003E Your algorithm&#39;s time complexity must be better than \u003Ccode\u003EO(n log n)\u003C/code\u003E, where n is the array&#39;s size.\u003C/p\u003E\n",
    "code": "const topKFrequent = function(nums, k) {\n  \n  // initialize a map to hold the count and num values\n  // for each num, create an array that holds [count,num]\n  // and increment the count whenever num is encountered\n  const map = {}\n  for(const num of nums){\n    if(!map[num]) map[num] = [0,num]\n    map[num][0]++\n  }\n  \n  // convert map to an array and sort from high to low count\n  const dp = Object.values(map).map((val) =\u003E val)\n  dp.sort((a,b) =\u003E b[0] - a[0])\n  \n  // return the num value for the first k elements \n  return dp.slice(0,k).map(([_,num]) =\u003E num)\n}",
    "tags": [
      "Array",
      "Hash Table",
      "Divide and Conquer",
      "Sorting",
      "Heap (Priority Queue)",
      "Bucket Sort",
      "Counting",
      "Quickselect"
    ],
    "created_at": "2024-10-13T21:58:19.469Z",
    "updated_at": "2024-10-13T21:58:19.469Z"
  },
  {
    "id": 16,
    "title": "Simplify Path",
    "content": "\u003Cp\u003EYou are given an \u003Cem\u003Eabsolute\u003C/em\u003E path for a Unix-style file system, which always begins with a slash \u003Ccode\u003E&#39;/&#39;\u003C/code\u003E. Your task is to transform this absolute path into its \u003Cstrong\u003Esimplified canonical path\u003C/strong\u003E.\u003C/p\u003E\n\n\u003Cp\u003EThe \u003Cem\u003Erules\u003C/em\u003E of a Unix-style file system are as follows:\u003C/p\u003E\n\n\u003Cul\u003E\n\t\u003Cli\u003EA single period \u003Ccode\u003E&#39;.&#39;\u003C/code\u003E represents the current directory.\u003C/li\u003E\n\t\u003Cli\u003EA double period \u003Ccode\u003E&#39;..&#39;\u003C/code\u003E represents the previous/parent directory.\u003C/li\u003E\n\t\u003Cli\u003EMultiple consecutive slashes such as \u003Ccode\u003E&#39;//&#39;\u003C/code\u003E and \u003Ccode\u003E&#39;///&#39;\u003C/code\u003E are treated as a single slash \u003Ccode\u003E&#39;/&#39;\u003C/code\u003E.\u003C/li\u003E\n\t\u003Cli\u003EAny sequence of periods that does \u003Cstrong\u003Enot match\u003C/strong\u003E the rules above should be treated as a \u003Cstrong\u003Evalid directory or\u003C/strong\u003E \u003Cstrong\u003Efile \u003C/strong\u003E\u003Cstrong\u003Ename\u003C/strong\u003E. For example, \u003Ccode\u003E&#39;...&#39; \u003C/code\u003Eand \u003Ccode\u003E&#39;....&#39;\u003C/code\u003E are valid directory or file names.\u003C/li\u003E\n\u003C/ul\u003E\n\n\u003Cp\u003EThe simplified canonical path should follow these \u003Cem\u003Erules\u003C/em\u003E:\u003C/p\u003E\n\n\u003Cul\u003E\n\t\u003Cli\u003EThe path must start with a single slash \u003Ccode\u003E&#39;/&#39;\u003C/code\u003E.\u003C/li\u003E\n\t\u003Cli\u003EDirectories within the path must be separated by exactly one slash \u003Ccode\u003E&#39;/&#39;\u003C/code\u003E.\u003C/li\u003E\n\t\u003Cli\u003EThe path must not end with a slash \u003Ccode\u003E&#39;/&#39;\u003C/code\u003E, unless it is the root directory.\u003C/li\u003E\n\t\u003Cli\u003EThe path must not have any single or double periods (\u003Ccode\u003E&#39;.&#39;\u003C/code\u003E and \u003Ccode\u003E&#39;..&#39;\u003C/code\u003E) used to denote current or parent directories.\u003C/li\u003E\n\u003C/ul\u003E\n\n\u003Cp\u003EReturn the \u003Cstrong\u003Esimplified canonical path\u003C/strong\u003E.\u003C/p\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 1:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cdiv class=\"example-block\"\u003E\n\u003Cp\u003E\u003Cstrong\u003EInput:\u003C/strong\u003E \u003Cspan class=\"example-io\"\u003Epath = &quot;/home/&quot;\u003C/span\u003E\u003C/p\u003E\n\n\u003Cp\u003E\u003Cstrong\u003EOutput:\u003C/strong\u003E \u003Cspan class=\"example-io\"\u003E&quot;/home&quot;\u003C/span\u003E\u003C/p\u003E\n\n\u003Cp\u003E\u003Cstrong\u003EExplanation:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cp\u003EThe trailing slash should be removed.\u003C/p\u003E\n\u003C/div\u003E\n\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 2:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cdiv class=\"example-block\"\u003E\n\u003Cp\u003E\u003Cstrong\u003EInput:\u003C/strong\u003E \u003Cspan class=\"example-io\"\u003Epath = &quot;/home//foo/&quot;\u003C/span\u003E\u003C/p\u003E\n\n\u003Cp\u003E\u003Cstrong\u003EOutput:\u003C/strong\u003E \u003Cspan class=\"example-io\"\u003E&quot;/home/foo&quot;\u003C/span\u003E\u003C/p\u003E\n\n\u003Cp\u003E\u003Cstrong\u003EExplanation:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cp\u003EMultiple consecutive slashes are replaced by a single one.\u003C/p\u003E\n\u003C/div\u003E\n\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 3:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cdiv class=\"example-block\"\u003E\n\u003Cp\u003E\u003Cstrong\u003EInput:\u003C/strong\u003E \u003Cspan class=\"example-io\"\u003Epath = &quot;/home/user/Documents/../Pictures&quot;\u003C/span\u003E\u003C/p\u003E\n\n\u003Cp\u003E\u003Cstrong\u003EOutput:\u003C/strong\u003E \u003Cspan class=\"example-io\"\u003E&quot;/home/user/Pictures&quot;\u003C/span\u003E\u003C/p\u003E\n\n\u003Cp\u003E\u003Cstrong\u003EExplanation:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cp\u003EA double period \u003Ccode\u003E&quot;..&quot;\u003C/code\u003E refers to the directory up a level (the parent directory).\u003C/p\u003E\n\u003C/div\u003E\n\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 4:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cdiv class=\"example-block\"\u003E\n\u003Cp\u003E\u003Cstrong\u003EInput:\u003C/strong\u003E \u003Cspan class=\"example-io\"\u003Epath = &quot;/../&quot;\u003C/span\u003E\u003C/p\u003E\n\n\u003Cp\u003E\u003Cstrong\u003EOutput:\u003C/strong\u003E \u003Cspan class=\"example-io\"\u003E&quot;/&quot;\u003C/span\u003E\u003C/p\u003E\n\n\u003Cp\u003E\u003Cstrong\u003EExplanation:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cp\u003EGoing one level up from the root directory is not possible.\u003C/p\u003E\n\u003C/div\u003E\n\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 5:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cdiv class=\"example-block\"\u003E\n\u003Cp\u003E\u003Cstrong\u003EInput:\u003C/strong\u003E \u003Cspan class=\"example-io\"\u003Epath = &quot;/.../a/../b/c/../d/./&quot;\u003C/span\u003E\u003C/p\u003E\n\n\u003Cp\u003E\u003Cstrong\u003EOutput:\u003C/strong\u003E \u003Cspan class=\"example-io\"\u003E&quot;/.../b/d&quot;\u003C/span\u003E\u003C/p\u003E\n\n\u003Cp\u003E\u003Cstrong\u003EExplanation:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cp\u003E\u003Ccode\u003E&quot;...&quot;\u003C/code\u003E is a valid name for a directory in this problem.\u003C/p\u003E\n\u003C/div\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EConstraints:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cul\u003E\n\t\u003Cli\u003E\u003Ccode\u003E1 &lt;= path.length &lt;= 3000\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003Epath\u003C/code\u003E consists of English letters, digits, period \u003Ccode\u003E&#39;.&#39;\u003C/code\u003E, slash \u003Ccode\u003E&#39;/&#39;\u003C/code\u003E or \u003Ccode\u003E&#39;_&#39;\u003C/code\u003E.\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003Epath\u003C/code\u003E is a valid absolute Unix path.\u003C/li\u003E\n\u003C/ul\u003E\n",
    "code": "const simplifyPath = (path) =\u003E {\n  \n  // initialize a stack and an array of files\n  // split by '/' this will eliminate any\n  // duplicate forward slashes and leave only \n  // with files and dot sequences\n  const stack = [], files = path.split('/')\n  \n  // iterate through files and if we encounter\n  // double dots and a files in the stack, \n  // remove the most recent file symbolizing\n  // going back one level in the file tree\n  for(const file of files){\n    if(file == '..'){\n      if(stack.length) stack.pop()\n      \n     // if the file is a valid string and not a \n     // singulare dot add it to the stack\n    }else if(file && file != '.'){\n      stack.push(file)\n    }\n  }\n  \n  // begin the path with a forward slash and\n  // append the files joined by a forward slash\n  return '/' + stack.join('/')\n}",
    "tags": [
      "String",
      "Stack"
    ],
    "created_at": "2024-10-15T01:02:20.923Z",
    "updated_at": "2024-10-15T01:02:20.923Z"
  },
  {
    "id": 34,
    "title": "Check Completeness of a Binary Tree",
    "content": "\u003Cp\u003EGiven the \u003Ccode\u003Eroot\u003C/code\u003E of a binary tree, determine if it is a \u003Cem\u003Ecomplete binary tree\u003C/em\u003E.\u003C/p\u003E\n\n\u003Cp\u003EIn a \u003Cstrong\u003E\u003Ca href=\"http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees\" target=\"_blank\"\u003Ecomplete binary tree\u003C/a\u003E\u003C/strong\u003E, every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between \u003Ccode\u003E1\u003C/code\u003E and \u003Ccode\u003E2\u003Csup\u003Eh\u003C/sup\u003E\u003C/code\u003E nodes inclusive at the last level \u003Ccode\u003Eh\u003C/code\u003E.\u003C/p\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 1:\u003C/strong\u003E\u003C/p\u003E\n\u003Cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/15/complete-binary-tree-1.png\" style=\"width: 180px; height: 145px;\" /\u003E\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E root = [1,2,3,4,5,6]\n\u003Cstrong\u003EOutput:\u003C/strong\u003E true\n\u003Cstrong\u003EExplanation:\u003C/strong\u003E Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible.\n\u003C/pre\u003E\n\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 2:\u003C/strong\u003E\u003C/p\u003E\n\u003Cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/15/complete-binary-tree-2.png\" style=\"width: 200px; height: 145px;\" /\u003E\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E root = [1,2,3,4,5,null,7]\n\u003Cstrong\u003EOutput:\u003C/strong\u003E false\n\u003Cstrong\u003EExplanation:\u003C/strong\u003E The node with value 7 isn&#39;t as far left as possible.\n\u003C/pre\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EConstraints:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cul\u003E\n\t\u003Cli\u003EThe number of nodes in the tree is in the range \u003Ccode\u003E[1, 100]\u003C/code\u003E.\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E1 &lt;= Node.val &lt;= 1000\u003C/code\u003E\u003C/li\u003E\n\u003C/ul\u003E\n",
    "code": "const isCompleteTree = (root) =\u003E {\n  \n  // initialize and array to hold arrays of\n  // each row in the binary tree\n  const levels = []\n  \n  // traverse the tree and keep track of the\n  // level of the current node at index level\n  // and push left value first and null if\n  // node doesn' exist this will result in \n  // an 2D array representation of the tree\n  const traverse = (node, level = 0) =\u003E {\n    if(!node){\n      if(!levels[level]) levels[level] = []\n      levels[level].push(null)\n      return\n    }\n    traverse(node.left, level + 1)\n    traverse(node.right, level + 1)\n    if(!levels[level]) levels[level] = []\n    levels[level].push(node.val)\n  }\n  traverse(root)\n  return validLevels(levels)\n}\n\n// helper function that will check the 2D\n// array representation of the tree and \n// return false if we encounter an instance\n// where a level has a value after an empty node\n// or we have reached the end of the previous row\n// and the current row has a valid node value\n// if else return true for a valid tree\nconst validLevels = (levels) =\u003E {\n  let i = 0, end = false\n  while(i \u003C levels.length){\n    let j = 0\n    while(j \u003C levels[i].length){\n      if(levels[i][j] == null){\n        end = true\n        if(levels[i][j + 1]) return false\n      }else if(end){\n        return false\n      }\n      j++\n    }\n    i++\n  }\n  return true\n}",
    "tags": [
      "Tree",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "created_at": "2024-10-18T03:18:14.198Z",
    "updated_at": "2024-10-18T03:18:14.198Z"
  },
  {
    "id": 67,
    "title": "Lowest Common Ancestor of a Binary Tree II",
    "content": "\u003Cp\u003EGiven the \u003Ccode\u003Eroot\u003C/code\u003E of a binary tree, return \u003Cem\u003Ethe lowest common ancestor (LCA) of two given nodes, \u003C/em\u003E\u003Ccode\u003Ep\u003C/code\u003E\u003Cem\u003E and \u003C/em\u003E\u003Ccode\u003Eq\u003C/code\u003E. If either node \u003Ccode\u003Ep\u003C/code\u003E or \u003Ccode\u003Eq\u003C/code\u003E \u003Cstrong\u003Edoes not exist\u003C/strong\u003E in the tree, return \u003Ccode\u003Enull\u003C/code\u003E. All values of the nodes in the tree are \u003Cstrong\u003Eunique\u003C/strong\u003E.\u003C/p\u003E\n\n\u003Cp\u003EAccording to the \u003Cstrong\u003E\u003Ca href=\"https://en.wikipedia.org/wiki/Lowest_common_ancestor\" target=\"_blank\"\u003Edefinition of LCA on Wikipedia\u003C/a\u003E\u003C/strong\u003E: &quot;The lowest common ancestor of two nodes \u003Ccode\u003Ep\u003C/code\u003E and \u003Ccode\u003Eq\u003C/code\u003E in a binary tree \u003Ccode\u003ET\u003C/code\u003E is the lowest node that has both \u003Ccode\u003Ep\u003C/code\u003E and \u003Ccode\u003Eq\u003C/code\u003E as \u003Cstrong\u003Edescendants\u003C/strong\u003E (where we allow \u003Cb\u003Ea node to be a descendant of itself\u003C/b\u003E)&quot;. A \u003Cstrong\u003Edescendant\u003C/strong\u003E of a node \u003Ccode\u003Ex\u003C/code\u003E is a node \u003Ccode\u003Ey\u003C/code\u003E that is on the path from node \u003Ccode\u003Ex\u003C/code\u003E to some leaf node.\u003C/p\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 1:\u003C/strong\u003E\u003C/p\u003E\n\u003Cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" /\u003E\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n\u003Cstrong\u003EOutput:\u003C/strong\u003E 3\n\u003Cstrong\u003EExplanation:\u003C/strong\u003E The LCA of nodes 5 and 1 is 3.\u003C/pre\u003E\n\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 2:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cp\u003E\u003Cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" /\u003E\u003C/p\u003E\n\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n\u003Cstrong\u003EOutput:\u003C/strong\u003E 5\n\u003Cstrong\u003EExplanation:\u003C/strong\u003E The LCA of nodes 5 and 4 is 5. A node can be a descendant of itself according to the definition of LCA.\u003C/pre\u003E\n\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 3:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cp\u003E\u003Cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" /\u003E\u003C/p\u003E\n\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 10\n\u003Cstrong\u003EOutput:\u003C/strong\u003E null\n\u003Cstrong\u003EExplanation:\u003C/strong\u003E Node 10 does not exist in the tree, so return null.\n\u003C/pre\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EConstraints:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cul\u003E\n\t\u003Cli\u003EThe number of nodes in the tree is in the range \u003Ccode\u003E[1, 10\u003Csup\u003E4\u003C/sup\u003E]\u003C/code\u003E.\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E-10\u003Csup\u003E9\u003C/sup\u003E &lt;= Node.val &lt;= 10\u003Csup\u003E9\u003C/sup\u003E\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003EAll \u003Ccode\u003ENode.val\u003C/code\u003E are \u003Cstrong\u003Eunique\u003C/strong\u003E.\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003Ep != q\u003C/code\u003E\u003C/li\u003E\n\u003C/ul\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cstrong\u003EFollow up:\u003C/strong\u003E&nbsp;Can you find the LCA traversing the tree, without checking nodes existence?",
    "code": "const lowestCommonAncestor = (root, p, q) =\u003E {\n  \n  // helper function to determine if node exists in tree\n  const findNode = (node, target) =\u003E {\n    \n    // return false if a non-existent node is reached\n    // and return true if the target node is reached\n    if(!node) return false\n    if(node == target) return true\n    \n    // traverse through left and right branches of the tree\n    const left = findNode(node.left, target)\n    const right = findNode(node.right, target)\n    \n    // return true if either left or right reaches target\n    return left || right\n  }\n  \n  // helper function for finding least common ancestor\n  const findLCA = (node, p, q) =\u003E {\n    \n    // return node whether we reach either node or null node\n    if(!node || node == p || node == q) return node\n    \n    // traverse through left and right branches of the tree\n    const left = findLCA(node.left, p, q)\n    const right = findLCA(node.right, p, q)\n    \n    // return node if both left and right reaches targets \n    // or either node that can be reached making that \n    // node the least common ancestor and the other a descendant\n    if(left && right) return node\n    return left ?? right\n  }\n    \n  // if either node does not exist in tree, return false, otherwise\n  // return the node from findLCA helper function\n  return (findNode(root,p) && findNode(root,q)) && findLCA(root, p, q)\n}",
    "tags": [
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "created_at": "2024-10-18T20:28:48.586Z",
    "updated_at": "2024-10-18T20:28:48.586Z"
  },
  {
    "id": 68,
    "title": "Palindromic Substrings",
    "content": "\u003Cp\u003EGiven a string \u003Ccode\u003Es\u003C/code\u003E, return \u003Cem\u003Ethe number of \u003Cstrong\u003Epalindromic substrings\u003C/strong\u003E in it\u003C/em\u003E.\u003C/p\u003E\n\n\u003Cp\u003EA string is a \u003Cstrong\u003Epalindrome\u003C/strong\u003E when it reads the same backward as forward.\u003C/p\u003E\n\n\u003Cp\u003EA \u003Cstrong\u003Esubstring\u003C/strong\u003E is a contiguous sequence of characters within the string.\u003C/p\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 1:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E s = &quot;abc&quot;\n\u003Cstrong\u003EOutput:\u003C/strong\u003E 3\n\u003Cstrong\u003EExplanation:\u003C/strong\u003E Three palindromic strings: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;.\n\u003C/pre\u003E\n\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 2:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E s = &quot;aaa&quot;\n\u003Cstrong\u003EOutput:\u003C/strong\u003E 6\n\u003Cstrong\u003EExplanation:\u003C/strong\u003E Six palindromic strings: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;.\n\u003C/pre\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EConstraints:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cul\u003E\n\t\u003Cli\u003E\u003Ccode\u003E1 &lt;= s.length &lt;= 1000\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003Es\u003C/code\u003E consists of lowercase English letters.\u003C/li\u003E\n\u003C/ul\u003E\n",
    "code": "const countSubstrings = function(s) {\n  \n  // initialize count to zero and iterate through\n  // s for each char in s run the helper function\n  // to count out from the center to find palidromes\n  // since some palidromes count have an odd number\n  // making the middle character inconsequential,\n  // start at both i & i and i & i + 1 for even lengths\n  let count = 0, i = 0\n  while(i \u003C s.length){\n    count += fromCenter(s, i, i)\n    count += fromCenter(s, i, i + 1)\n    i++\n  }\n  return count\n}\n\nconst fromCenter = (s, i, j) =\u003E {\n  let count = 0\n  while(i \u003E= 0 && j \u003C s.length && s[i] == s[j]){\n    count++\n    i--\n    j++\n  }\n  return count\n}\n",
    "tags": [
      "String",
      "Two Pointers",
      "Dynamic Programming"
    ],
    "created_at": "2024-10-21T17:29:46.762Z",
    "updated_at": "2024-10-21T17:29:46.762Z"
  },
  {
    "id": 69,
    "title": "Smallest Subtree with all the Deepest Nodes",
    "content": "\u003Cp\u003EGiven the \u003Ccode\u003Eroot\u003C/code\u003E of a binary tree, the depth of each node is \u003Cstrong\u003Ethe shortest distance to the root\u003C/strong\u003E.\u003C/p\u003E\n\n\u003Cp\u003EReturn \u003Cem\u003Ethe smallest subtree\u003C/em\u003E such that it contains \u003Cstrong\u003Eall the deepest nodes\u003C/strong\u003E in the original tree.\u003C/p\u003E\n\n\u003Cp\u003EA node is called \u003Cstrong\u003Ethe deepest\u003C/strong\u003E if it has the largest depth possible among any node in the entire tree.\u003C/p\u003E\n\n\u003Cp\u003EThe \u003Cstrong\u003Esubtree\u003C/strong\u003E of a node is a tree consisting of that node, plus the set of all descendants of that node.\u003C/p\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 1:\u003C/strong\u003E\u003C/p\u003E\n\u003Cimg alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png\" style=\"width: 600px; height: 510px;\" /\u003E\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E root = [3,5,1,6,2,0,8,null,null,7,4]\n\u003Cstrong\u003EOutput:\u003C/strong\u003E [2,7,4]\n\u003Cstrong\u003EExplanation:\u003C/strong\u003E We return the node with value 2, colored in yellow in the diagram.\nThe nodes coloured in blue are the deepest nodes of the tree.\nNotice that nodes 5, 3 and 2 contain the deepest nodes in the tree but node 2 is the smallest subtree among them, so we return it.\n\u003C/pre\u003E\n\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 2:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E root = [1]\n\u003Cstrong\u003EOutput:\u003C/strong\u003E [1]\n\u003Cstrong\u003EExplanation:\u003C/strong\u003E The root is the deepest node in the tree.\n\u003C/pre\u003E\n\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 3:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E root = [0,1,3,null,2]\n\u003Cstrong\u003EOutput:\u003C/strong\u003E [2]\n\u003Cstrong\u003EExplanation:\u003C/strong\u003E The deepest node in the tree is 2, the valid subtrees are the subtrees of nodes 2, 1 and 0 but the subtree of node 2 is the smallest.\n\u003C/pre\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EConstraints:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cul\u003E\n\t\u003Cli\u003EThe number of nodes in the tree will be in the range \u003Ccode\u003E[1, 500]\u003C/code\u003E.\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E0 &lt;= Node.val &lt;= 500\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003EThe values of the nodes in the tree are \u003Cstrong\u003Eunique\u003C/strong\u003E.\u003C/li\u003E\n\u003C/ul\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003ENote:\u003C/strong\u003E This question is the same as 1123: \u003Ca href=\"https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/\" target=\"_blank\"\u003Ehttps://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/\u003C/a\u003E\u003C/p\u003E\n",
    "code": "const subtreeWithAllDeepest = (root) =\u003E {\n  let deepest = 0, nodes = []\n  \n  // traverse tree to find the nodes at the deepest level\n  const findDeepestLevel = (node, level = 0) =\u003E {\n    if(!node) return \n    if(level \u003E deepest){\n      nodes = [node.val]\n      deepest = level\n    }else if(level == deepest){\n      nodes.push(node.val)\n    }\n    findDeepestLevel(node.left, level + 1)\n    findDeepestLevel(node.right, level + 1)\n  }\n  \n  // traverse tree to find the least common parent\n  // that has all nodes at the deepest level \n  const findDeepestTree = (node) =\u003E { \n    if(!node) return node\n    if(nodes.includes(node.val)) return node\n    const left = findDeepestTree(node.left)\n    const right = findDeepestTree(node.right)\n    if(left && right) return node\n    return left || right\n  }\n  findDeepestLevel(root)\n  return findDeepestTree(root)\n}",
    "tags": [
      "Hash Table",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "created_at": "2024-10-22T18:21:49.540Z",
    "updated_at": "2024-10-22T18:21:49.540Z"
  },
  {
    "id": 100,
    "title": "Tree Diameter",
    "content": "\u003Cp\u003EThe \u003Cstrong\u003Ediameter\u003C/strong\u003E of a tree is \u003Cstrong\u003Ethe number of edges\u003C/strong\u003E in the longest path in that tree.\u003C/p\u003E\n\n\u003Cp\u003EThere is an undirected tree of \u003Ccode\u003En\u003C/code\u003E nodes labeled from \u003Ccode\u003E0\u003C/code\u003E to \u003Ccode\u003En - 1\u003C/code\u003E. You are given a 2D array \u003Ccode\u003Eedges\u003C/code\u003E where \u003Ccode\u003Eedges.length == n - 1\u003C/code\u003E and \u003Ccode\u003Eedges[i] = [a\u003Csub\u003Ei\u003C/sub\u003E, b\u003Csub\u003Ei\u003C/sub\u003E]\u003C/code\u003E indicates that there is an undirected edge between nodes \u003Ccode\u003Ea\u003Csub\u003Ei\u003C/sub\u003E\u003C/code\u003E and \u003Ccode\u003Eb\u003Csub\u003Ei\u003C/sub\u003E\u003C/code\u003E in the tree.\u003C/p\u003E\n\n\u003Cp\u003EReturn \u003Cem\u003Ethe \u003Cstrong\u003Ediameter\u003C/strong\u003E of the tree\u003C/em\u003E.\u003C/p\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 1:\u003C/strong\u003E\u003C/p\u003E\n\u003Cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/01/19/tree1.jpg\" style=\"width: 224px; height: 145px;\" /\u003E\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E edges = [[0,1],[0,2]]\n\u003Cstrong\u003EOutput:\u003C/strong\u003E 2\n\u003Cstrong\u003EExplanation:\u003C/strong\u003E The longest path of the tree is the path 1 - 0 - 2.\n\u003C/pre\u003E\n\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 2:\u003C/strong\u003E\u003C/p\u003E\n\u003Cimg alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/01/19/tree2.jpg\" style=\"width: 224px; height: 225px;\" /\u003E\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E edges = [[0,1],[1,2],[2,3],[1,4],[4,5]]\n\u003Cstrong\u003EOutput:\u003C/strong\u003E 4\n\u003Cstrong\u003EExplanation:\u003C/strong\u003E The longest path of the tree is the path 3 - 2 - 1 - 4 - 5.\n\u003C/pre\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EConstraints:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cul\u003E\n\t\u003Cli\u003E\u003Ccode\u003En == edges.length + 1\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E1 &lt;= n &lt;= 10\u003Csup\u003E4\u003C/sup\u003E\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E0 &lt;= a\u003Csub\u003Ei\u003C/sub\u003E, b\u003Csub\u003Ei\u003C/sub\u003E &lt; n\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003Ea\u003Csub\u003Ei\u003C/sub\u003E != b\u003Csub\u003Ei\u003C/sub\u003E\u003C/code\u003E\u003C/li\u003E\n\u003C/ul\u003E\n",
    "code": "const treeDiameter = (edges) =\u003E {\n  \n  // if empty array return 0 as max\n  if(!edges.length) return 0\n  \n  // create an adjacency list for edges between nodes\n  const adj = {}\n  for(const [x,y] of edges){\n    if(!adj[x]) adj[x] = []\n    adj[x].push(y)\n    if(!adj[y]) adj[y] = []\n    adj[y].push(x)\n  }\n  \n  // define furthest as the furthest node from any \n  // node and define count as the distnace of the \n  // furthest node from that node and return count\n  const furthest = followFurthest(0,adj)[0]\n  const count = followFurthest(furthest,adj)[1]\n  return count\n}\n\n// helper function that returns the furthest node\n// and distance from a given node and adjacency list\nconst followFurthest = (node, list) =\u003E {\n  const seen = new Set(), q = [[node,0]]\n  seen.add(node)\n  while(q.length){\n    const [cur,len] = q.shift()\n    for(const next of list[cur]){\n      if(!seen.has(next)){\n        seen.add(next)\n        q.push([next,len+1])\n      }\n    }\n    \n    // if queue is empty the furthest possible node\n    // must be the current node in our while loop\n    if(!q.length) return [cur,len]\n  }\n}",
    "tags": [
      "Graph",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Topological Sort"
    ],
    "created_at": "2024-10-27T04:18:49.552Z",
    "updated_at": "2024-10-27T04:18:49.552Z"
  },
  {
    "id": 133,
    "title": "Find the Substring With Maximum Cost",
    "content": "\u003Cp\u003EYou are given a string \u003Ccode\u003Es\u003C/code\u003E, a string \u003Ccode\u003Echars\u003C/code\u003E of \u003Cstrong\u003Edistinct\u003C/strong\u003E characters and an integer array \u003Ccode\u003Evals\u003C/code\u003E of the same length as \u003Ccode\u003Echars\u003C/code\u003E.\u003C/p\u003E\n\n\u003Cp\u003EThe \u003Cstrong\u003Ecost of the substring \u003C/strong\u003Eis the sum of the values of each character in the substring. The cost of an empty string is considered \u003Ccode\u003E0\u003C/code\u003E.\u003C/p\u003E\n\n\u003Cp\u003EThe \u003Cstrong\u003Evalue of the character \u003C/strong\u003Eis defined in the following way:\u003C/p\u003E\n\n\u003Cul\u003E\n\t\u003Cli\u003EIf the character is not in the string \u003Ccode\u003Echars\u003C/code\u003E, then its value is its corresponding position \u003Cstrong\u003E(1-indexed)\u003C/strong\u003E in the alphabet.\n\n\t\u003Cul\u003E\n\t\t\u003Cli\u003EFor example, the value of \u003Ccode\u003E&#39;a&#39;\u003C/code\u003E is \u003Ccode\u003E1\u003C/code\u003E, the value of \u003Ccode\u003E&#39;b&#39;\u003C/code\u003E is \u003Ccode\u003E2\u003C/code\u003E, and so on. The value of \u003Ccode\u003E&#39;z&#39;\u003C/code\u003E is \u003Ccode\u003E26\u003C/code\u003E.\u003C/li\u003E\n\t\u003C/ul\u003E\n\t\u003C/li\u003E\n\t\u003Cli\u003EOtherwise, assuming \u003Ccode\u003Ei\u003C/code\u003E is the index where the character occurs in the string \u003Ccode\u003Echars\u003C/code\u003E, then its value is \u003Ccode\u003Evals[i]\u003C/code\u003E.\u003C/li\u003E\n\u003C/ul\u003E\n\n\u003Cp\u003EReturn \u003Cem\u003Ethe maximum cost among all substrings of the string\u003C/em\u003E \u003Ccode\u003Es\u003C/code\u003E.\u003C/p\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 1:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E s = &quot;adaa&quot;, chars = &quot;d&quot;, vals = [-1000]\n\u003Cstrong\u003EOutput:\u003C/strong\u003E 2\n\u003Cstrong\u003EExplanation:\u003C/strong\u003E The value of the characters &quot;a&quot; and &quot;d&quot; is 1 and -1000 respectively.\nThe substring with the maximum cost is &quot;aa&quot; and its cost is 1 + 1 = 2.\nIt can be proven that 2 is the maximum cost.\n\u003C/pre\u003E\n\n\u003Cp\u003E\u003Cstrong class=\"example\"\u003EExample 2:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cpre\u003E\n\u003Cstrong\u003EInput:\u003C/strong\u003E s = &quot;abc&quot;, chars = &quot;abc&quot;, vals = [-1,-1,-1]\n\u003Cstrong\u003EOutput:\u003C/strong\u003E 0\n\u003Cstrong\u003EExplanation:\u003C/strong\u003E The value of the characters &quot;a&quot;, &quot;b&quot; and &quot;c&quot; is -1, -1, and -1 respectively.\nThe substring with the maximum cost is the empty substring &quot;&quot; and its cost is 0.\nIt can be proven that 0 is the maximum cost.\n\u003C/pre\u003E\n\n\u003Cp\u003E&nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EConstraints:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cul\u003E\n\t\u003Cli\u003E\u003Ccode\u003E1 &lt;= s.length &lt;= 10\u003Csup\u003E5\u003C/sup\u003E\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003Es\u003C/code\u003E consist of lowercase English letters.\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E1 &lt;= chars.length &lt;= 26\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003Echars\u003C/code\u003E consist of \u003Cstrong\u003Edistinct\u003C/strong\u003E lowercase English letters.\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003Evals.length == chars.length\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E-1000 &lt;= vals[i] &lt;= 1000\u003C/code\u003E\u003C/li\u003E\n\u003C/ul\u003E\n",
    "code": "const maximumCostSubstring = (s, chars, vals) =\u003E {\n  \n  //initialize arr to hold values for each character\n  const arr = []\n  \n  // traverse characters in string and push their value\n  // to arr if in vals array, else get their value using\n  // the char code for the character\n  for(const char of s){\n    const idx = chars.indexOf(char)\n    if(idx \u003E= 0){\n      arr.push(vals[idx])\n    }else{\n      arr.push(char.charCodeAt(0) - 96)\n    }\n  }\n  \n  // use Kadane's algorithms to find maximum sub value\n  let curMax = 0, finalMax = 0\n  for(const cost of arr){\n    curMax = Math.max(0, curMax + cost)\n    finalMax = Math.max(finalMax, curMax)\n  }\n  return finalMax\n}",
    "tags": [
      "Array",
      "Hash Table",
      "String",
      "Dynamic Programming"
    ],
    "created_at": "2024-11-11T21:23:10.875Z",
    "updated_at": "2024-11-11T21:23:10.875Z"
  }
]