[
  {
    "id": 1,
    "title": "palleteplayground",
    "description": "This micro web app provides an intuitive and simple way to generate beautiful color schemes based on various color theory principles. Users can explore different scheme types like Monochromatic, Analogous, Complementary, Triadic, and Tetradic to create harmonious color combinations for their designs. By selecting a base color, the app instantly generates a range of complementary colors tailored to the selected scheme type. Users can view, copy, and export hex codes for use in design projects, web development, or branding. With a clean, user-friendly interface, this tool makes it easy for designers, developers, and creatives to quickly experiment with colors and find the perfect palette for any project.",
    "image": "https://imgur.com/O7xeUhg.png",
    "github_link": "https://github.com/donovanodom/paletteplayground",
    "site": "https://paletteplayground.vercel.app",
    "created_at": "2024-10-11T19:38:59.700Z",
    "updated_at": "2024-10-19T01:07:28.006Z",
    "snippet": "// generators.ts file to generate colors based on given color scheme\n\nconst namer = require('color-namer')\n\nexport const randomNumber = (min: number, max: number): number =\u003E {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\nconst hslToName = (hsl: number[]): string =\u003E {\n  return namer(hslToHex(hsl),{pick: ['ntc'], distance: 'deltaE'})['ntc'][0]['name'] || 'unknowncolor'\n}\n\nconst hslToHex = (hsl: number[]): string =\u003E {\n  let [h,s,l] = hsl\n  l /= 100;\n  const a = (s * Math.min(l, 1 - l)) / 100;\n  const f = (n: any) =\u003E {\n    const k = (n + h / 30) % 12;\n    const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n    return Math.round(255 * color)\n      .toString(16)\n      .padStart(2, \"0\");\n  };\n  return `#${f(0)}${f(8)}${f(4)}`.toUpperCase();\n};\n\nconst hexToRgb = (hex: string): string =\u003E {\n  hex = hex.slice(1)\n  let RgbHex = hex.match(/.{1,2}/g);\n  if(!RgbHex) return ''\n  return `rgb(${parseInt(RgbHex[0], 16)}, ${parseInt(RgbHex[1], 16)}, ${parseInt(RgbHex[2], 16)})`\n}\n\nexport const generateBase = () =\u003E {\n  const hsl = [randomNumber(0, 360), randomNumber(0, 100), randomNumber(0, 100)]\n  const name = hslToName(hsl)\n  const hexName = hslToHex(hsl)\n  const rgbName = hexToRgb(hexName)\n  return {\n    hsl: hsl,\n    name: name,\n    hexName: hexName,\n    rgbName: rgbName\n  }\n}\n\nfunction sortColors(colors: Color[]) {\n  return colors\n    .sort((colorA, colorB) =\u003E {\n      if (colorA.hsl[2] \u003C colorB.hsl[2]) {\n        return -1;\n      } else if (colorA.hsl[2] \u003E colorB.hsl[2]) {\n        return 1;\n      } else {\n        return 0;\n      }\n    });\n}\n\nconst monoChromatic = (base: Color, scheme: string, count: number, current: Colors = []): ColorsObject =\u003E {\n  const updated: Colors = current.length ? [...current] : [base], piv = [...base.hsl]\n  while(count \u003C updated.length){\n    updated.pop()\n  }\n  while(updated.length \u003C count){\n    let h = randomNumber(-5,-1), s = randomNumber(-20,-1), l = randomNumber(-20,-1)\n    piv[0] = piv[0] + h \u003C 5 ? randomNumber(1,5) : piv[0] + h\n    piv[1] = piv[1] + s \u003C 20 ? randomNumber(20,95) : piv[1] + s\n    piv[2] = piv[2] + l \u003C 20 ? randomNumber(20,95) : piv[2] + l\n\n    const newHsl = [...piv]\n    const name = hslToName(newHsl)\n    const hexName = hslToHex(newHsl)\n    const rgbName = hexToRgb(hexName)\n\n    updated.push({\n      hsl: newHsl,\n      name: name,\n      hexName: hexName,\n      rgbName: rgbName\n    })\n  }\n  \n  return {\n    count,\n    base,\n    scheme,\n    colors: sortColors(updated),\n  }\n}\n\nconst analogous = (base: Color, scheme: string, count: number, current: Colors = []): ColorsObject =\u003E {\n  const updated: Colors = current.length ? [...current] : [base], piv = [...base.hsl], shift = [0,-35,-70,35,70]\n  while(count \u003C updated.length){\n    updated.pop()\n  }\n  let adj = 0\n  while(updated.length \u003C count){\n    if(adj \u003E 4) adj = 0\n    let s = randomNumber(-20,-1), l = randomNumber(-20,-1)\n    piv[1] = piv[1] + s \u003C 20 ? randomNumber(20,95) : piv[1] + s\n    piv[2] = piv[2] + l \u003C 20 ? randomNumber(20,95) : piv[2] + l\n    piv[0] = piv[0] + shift[adj] \u003C 0 ? piv[0] - shift[adj] + 360 : piv[0] + shift[adj] \u003E 359 ? piv[0] + shift[adj] - 360 : piv[0] + shift[adj]\n\n    const newHsl = [...piv]\n    const name = hslToName(newHsl)\n    const hexName = hslToHex(newHsl)\n    const rgbName = hexToRgb(hexName)\n\n    updated.push({\n      hsl: newHsl,\n      name: name,\n      hexName: hexName,\n      rgbName: rgbName\n    })\n    adj++\n  }\n\n  return {\n    count,\n    base,\n    scheme,\n    colors: sortColors(updated),\n  }\n}\n\nconst complimentary = (base: Color, scheme: string, count: number, current: Colors = []): ColorsObject =\u003E {\n  const updated: Colors = current.length ? [...current] : [base], piv = [...base.hsl]\n  while(count \u003C updated.length){\n    updated.pop()\n  }\n  while(updated.length \u003C count){\n    const comp = piv[0] - 180 \u003C 0 ? piv[0] + 180 : piv[0] - 180\n    let s = randomNumber(-20,-1), l = randomNumber(-20,-1)\n    piv[1] = piv[1] + s \u003C 20 ? randomNumber(20,95) : piv[1] + s\n    piv[2] = piv[2] + l \u003C 20 ? randomNumber(20,95) : piv[2] + l\n    if(updated.length % 2 == 0) piv[0] = comp\n\n    const newHsl = [...piv]\n    const name = hslToName(newHsl)\n    const hexName = hslToHex(newHsl)\n    const rgbName = hexToRgb(hexName)\n\n    updated.push({\n      hsl: newHsl,\n      name: name,\n      hexName: hexName,\n      rgbName: rgbName\n    })\n  }\n  \n  return {\n    count,\n    base,\n    scheme,\n    colors: sortColors(updated),\n  }\n}\n\nconst splitComplimentary = (base: Color, scheme: string, count: number, current: Colors = []): ColorsObject =\u003E {\n  const updated: Colors = current.length ? [...current] : [base], piv = [...base.hsl]\n  while(count \u003C updated.length){\n    updated.pop()\n  }\n  while(updated.length \u003C count){\n    if(updated.length % 2 != 0){\n      const comp = piv[0] - 180 \u003C 0 ? piv[0] + 180 : piv[0] - 180\n      piv[0] = comp\n    }\n    let s = randomNumber(-50,-30), l = randomNumber(-50,-30)\n    piv[1] = piv[1] + s \u003C 20 ? randomNumber(50,95) : piv[1] + s\n    piv[2] = piv[2] + l \u003C 20 ? randomNumber(50,95) : piv[2] + l\n    \n    const newHsl = [...piv]\n    const name = hslToName(newHsl)\n    const hexName = hslToHex(newHsl)\n    const rgbName = hexToRgb(hexName)\n\n    updated.push({\n      hsl: newHsl,\n      name: name,\n      hexName: hexName,\n      rgbName: rgbName\n    })\n  }\n  \n  return {\n    count,\n    base,\n    scheme,\n    colors: sortColors(updated),\n  }\n}\n\nconst triadic = (base: Color, scheme: string, count: number, current: Colors = []): ColorsObject =\u003E {\n  const updated: Colors = current.length ? [...current] : [base], piv = [...base.hsl]\n  const t1 = piv[0] - 120 \u003C 0 ? 360 + piv[0] - 120 : piv[0] - 120, t2 = t1 - 120 \u003C 0 ? 360 + t1 - 120 : t1 - 120\n  while(count \u003C updated.length){\n    updated.pop()\n  }\n  while(updated.length \u003C count){\n    let h = randomNumber(-5,-1), s = randomNumber(-20,1), l = randomNumber(-20,1), cur = randomNumber(1,3)\n    if(cur == 1){\n      piv[0] = t1 \n      piv[1] = piv[1] + s \u003C 20 ? randomNumber(20,95) : piv[1] + s\n      piv[2] = piv[2] + l \u003C 20 ? randomNumber(20,95) : piv[2] + l\n    }else if(cur == 2){\n      piv[0] = t2\n      piv[1] = piv[1] + s \u003C 20 ? randomNumber(20,95) : piv[1] + s\n      piv[2] = piv[2] + l \u003C 20 ? randomNumber(20,95) : piv[2] + l\n    }else{\n      piv[0] = piv[0] + h \u003C 5 ? randomNumber(1,5) : piv[0] + h\n      piv[1] = piv[1] + s \u003C 20 ? randomNumber(20,95) : piv[1] + s\n      piv[2] = piv[2] + l \u003C 20 ? randomNumber(20,95) : piv[2] + l\n    }\n \n    const newHsl = [...piv]\n    const name = hslToName(newHsl) \n    const hexName = hslToHex(newHsl)\n    const rgbName = hexToRgb(hexName)\n\n    updated.push({\n      hsl: newHsl,\n      name: name,\n      hexName: hexName,\n      rgbName: rgbName\n    })\n  }\n  \n  return {\n    count,\n    base,\n    scheme,\n    colors: sortColors(updated),\n  }\n}\n\nconst square = (base: Color, scheme: string, count: number, current: Colors = []): ColorsObject =\u003E {\n  const updated: Colors = current.length ? [...current] : [base], piv = [...base.hsl]\n  const t1 = piv[0] - 90 \u003C 0 ? 270 + piv[0]: piv[0] - 90, t2 = t1 - 90 \u003C 0 ? 270 + t1 : t1 - 90, t3 = t2 - 90 \u003C 0 ? 270 + t2 : t2 - 90\n  while(count \u003C updated.length){\n    updated.pop()\n  }\n  while(updated.length \u003C count){\n    let h = randomNumber(-5,-1), s = randomNumber(-20,1), l = randomNumber(-20,1), cur = randomNumber(1,4)\n    if(cur == 1){\n      piv[0] = t1 \n      piv[1] = piv[1] + s \u003C 20 ? randomNumber(20,95) : piv[1] + s\n      piv[2] = piv[2] + l \u003C 20 ? randomNumber(20,95) : piv[2] + l\n    }else if(cur == 2){\n      piv[0] = t2\n      piv[1] = piv[1] + s \u003C 20 ? randomNumber(20,95) : piv[1] + s\n      piv[2] = piv[2] + l \u003C 20 ? randomNumber(20,95) : piv[2] + l\n    }else if(cur == 3){\n      piv[0] = piv[0] + h \u003C 5 ? randomNumber(1,5) : piv[0] + h\n      piv[1] = piv[1] + s \u003C 20 ? randomNumber(20,95) : piv[1] + s\n      piv[2] = piv[2] + l \u003C 20 ? randomNumber(20,95) : piv[2] + l\n    }else{\n      piv[0] = t3\n      piv[1] = piv[1] + s \u003C 20 ? randomNumber(20,95) : piv[1] + s\n      piv[2] = piv[2] + l \u003C 20 ? randomNumber(20,95) : piv[2] + l\n    }\n \n    const newHsl = [...piv]\n    const name = hslToName(newHsl) \n    const hexName = hslToHex(newHsl)\n    const rgbName = hexToRgb(hexName)\n\n    updated.push({\n      hsl: newHsl,\n      name: name,\n      hexName: hexName,\n      rgbName: rgbName\n    })\n\n    if(cur == 2){\n      piv[1] = piv[1] + s \u003C 20 ? randomNumber(20,95) : piv[1] + s\n      piv[2] = piv[2] + l \u003C 20 ? randomNumber(20,95) : piv[2] + l\n    }\n  }\n  \n  return {\n    count,\n    base,\n    scheme,\n    colors: sortColors(updated),\n  }\n}\n\nexport const schemes: any = {\n  'Monochromatic': monoChromatic,\n  'Analogous': analogous,\n  'Complimentary': complimentary,\n  'Split Complimentary': splitComplimentary,\n  'Triadic': triadic,\n  'Square': square\n};\n"
  },
  {
    "id": 35,
    "title": "sign-up validation",
    "description": "This Signup Component is built with React and TypeScript and uses zxcvbn to measure password strength. It validates inputs on the client side, giving instant feedback like inline error messages like an invalid email or a short username. The password strength meter updates live as you type, showing if the password is weak, okay, good, strong or very strong. The whole thing works great on both desktop and mobile, giving users a smooth experience while encouraging stronger passwords without the hassle.",
    "image": "https://imgur.com/tTtLNhb.png",
    "github_link": "https://github.com/donovanodom/signup-validation",
    "site": "https://donovanodom.github.io/signup-validation",
    "created_at": "2024-10-19T01:19:38.581Z",
    "updated_at": "2024-10-19T01:32:31.728Z",
    "snippet": "// validation.ts file to handle validating form inputs\n\nexport const validateSignUpParams = (params: SignUpParams, passwordStrength: number): SignUpErrors =\u003E {\n  const errors: SignUpErrors = {\n    firstName: [],\n    lastName: [],\n    username: [],\n    email: [],\n    password: [],\n    passwordConfirmation: [],\n  } \n\n  Object.keys(params).forEach((key) =\u003E {\n    switch(key) {\n      case 'firstName':\n        const firstNameErrors = validateName(params.firstName, 'First Name')\n        errors.firstName = firstNameErrors\n      case 'lastName':\n        const lastNameErrors = validateName(params.lastName, 'Last Name')\n        errors.lastName = lastNameErrors\n      case 'username':\n        const usernameErrors = validateUsername(params.username)\n        errors.username = usernameErrors\n      case 'email':\n        const emailErrors = validateEmail(params.email)\n        errors.email = emailErrors\n      case 'password':\n        const passwordErrors = validatePassword(params.password, passwordStrength)\n        errors.password = passwordErrors\n      case 'passwordConfirmation':\n        const passwordConfirmationErrors = validatePasswordConfirmation(params.passwordConfirmation, params.password)\n        errors.passwordConfirmation = passwordConfirmationErrors\n    }\n  })\n  return errors\n}\n\nexport const isValidSignUpParams = (errors: SignUpErrors) =\u003E {\n  let valid = true\n  Object.keys(errors).forEach((key) =\u003E {\n    if(errors[key as keyof SignUpErrors].length) valid = false\n  })\n  return valid\n}\n\nconst validateName = (value: string, type: string) =\u003E {\n  const errors: string[] = []\n  if(value.length === 0){\n    errors.push(`${type} can't be blank`)\n    return errors\n  }\n  if(/^[a-zA-Z]+$/.test(value) === false) errors.push(`${type} can only be letters`)\n  if(value.length \u003C 2) errors.push(`${type} is too short (minimum is 2 characters)`)\n  if(value.length \u003E 50) errors.push(`${type} is too long (maximum is 50 characters)`)\n  if(/\\s/.test(value)) errors.push(`${type} must not have any blank spaces`)\n  return errors\n}\n\nconst validateUsername = (value: string) =\u003E {\n  const errors: string[] = []\n  if(value.length === 0){\n    errors.push(`Username can't be blank`)\n    return errors\n  }\n  if(/^[a-zA-Z0-9_]*$/.test(value) === false) errors.push(`Username can only be letters, numbers or underscores`)\n  if(value.length \u003C 3) errors.push(`Username is too short (minimum is 3 characters)`)\n  if(value.length \u003E 15) errors.push(`Username is too long (maximum is 15 characters)`)\n  if(/\\s/.test(value)) errors.push(`Username must not have any blank spaces`)\n  return errors\n}\n\nconst validateEmail = (value: string) =\u003E {\n  const errors: string[] = []\n  if(value.length === 0){\n    errors.push(`Email can't be blank`)\n    return errors\n  }\n  if(/^([a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,})$/.test(value) === false) errors.push(`Email ${value} is not a valid email address`)\n  if(/\\s/.test(value)) errors.push(`Email must not have any blank spaces`)\n  return errors\n}\n\nconst validatePassword = (value: string, passwordStrength: number) =\u003E {\n  const errors: string[] = []\n  if(value.length === 0){\n    errors.push(`Password can't be blank`)\n    return errors\n  }\n  if(passwordStrength \u003C 3) errors.push('Password not strong enough')\n  if(value.length \u003C 10) errors.push(`Password is too short (minimum is 10 characters)`)\n  if(value.length \u003E 30) errors.push(`Password is too long (maximum is 30 characters)`)\n  if(/[A-Z]+/.test(value) === false) errors.push('Password must contain at least one capital letter')\n  if(/[a-z]+/.test(value) === false) errors.push('Password must contain at least one lowercase letter')\n  if(/\\d+/.test(value) === false) errors.push('Password must contain at least one number')\n  if(/^[0-9A-Za-z$@!_-]*$/.test(value) === false) errors.push(\"Password can only have '$', '@', '!', '_', or '-' as special characters\")\n  if(/\\s/.test(value)) errors.push(`Password must not have any blank spaces`)\n  return errors\n}\n\nconst validatePasswordConfirmation = (value: string, compare: string) =\u003E {\n  const errors: string[] = []\n  if(value.length === 0){\n    errors.push(`Password Confirmation can't be blank`)\n    return errors\n  }\n  if(value !== compare) errors.push(\"Password Confirmation doesn't match\")\n  return errors\n}"
  }
]